<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | TechInno</title>
	<meta name="description"
		content="Korean Programmer">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="TechInno"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">TechInno</a>
		</h1>
		<br><h1 class="site-description">Korean Programmer</h1></br>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			












































            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
    
      "leetcode-2020-02-03-word-search-ii-html": {
        "title": "Word Search II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a 2D board and a list of words from the dictionary, find all words in the board.Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.Example 1:Input: board = [  ['o','a','a','n'],  ['e','t','a','e'],  ['i','h','k','r'],  ['i','f','l','v']]words = [\"oath\",\"pea\",\"eat\",\"rain\"]Output: [\"eat\",\"oath\"]Note :  All inputs are consist of lowercase letters a-z  The values of words are distinctMy Answer  board의 원소들을 순회 하면서 각 원소의 사방으로 이웃한 노드를 Trie로 구성한다.  반복횟수가 너무 많은 문제가 있다.class Trie {    public boolean use;    public char val;    public List&lt;Trie&gt; neighbors;    public Trie(char c) {        neighbors = new ArrayList&lt;&gt;();        val = c;    }       public boolean search(Trie trie, char[] array, int index ) {        if ( trie == null ) return false;        if ( array.length == index ) return true;                char c = array[index];        for ( Trie next : trie.neighbors ) {            if ( next.val != c ) continue;            if ( next.use ) continue;            next.use = true;            if ( search(next, array, index + 1)) {                next.use = false;                return true;                              }                         next.use = false;        }                return false;                }}class Solution {    public List&lt;String&gt; findWords(char[][] board, String[] words) {        Trie trie = new Trie('-');        int height=board.length;        int width=board[0].length;                for(int y=0;y&lt;height;y++) {            for(int x=0;x&lt;width;x++) {                trie.neighbors.add(new Trie(board[y][x]));            }        }                for(int y=0;y&lt;height;y++) {            for(int x=0;x&lt;width;x++) {                int cur_idx = x + width * y;                Trie center = trie.neighbors.get(cur_idx);                                for(int i=0;i&lt;4;i++) {                    int new_x=x;                    int new_y=y;                    int neighbor_idx = 0;                    if ( i == 0 ) {                        new_x = x-1;                                            } else if( i == 1) {                        new_x = x+1;                    } else if ( i == 2) {                        new_y = y-1;                    } else {                        new_y = y+1;                    }                                        if ( new_x &lt; 0 || new_x &gt;= width || new_y &lt; 0 || new_y &gt;= height )                        continue;                                        neighbor_idx = new_x + width * new_y;                                        if ( neighbor_idx &lt; 0 || neighbor_idx &gt;= trie.neighbors.size())                        continue;                                        center.neighbors.add(trie.neighbors.get(neighbor_idx));                }            }        }                List&lt;String&gt; result = new ArrayList&lt;&gt;();                for (String word : words ) {            if ( trie.search(trie, word.toCharArray(), 0) ) {                result.add(word);            }        }        return result;    }    }Fastest Answer  words의 원소들을 이용해서 Trie를 구성하고, board에 맞는것을 찾자.class Trie {    public String word;        public Trie[] children;    public Trie() {        children = new Trie[26];    }           public void insert(String str) {        Trie cur = this;        for(char c : str.toCharArray()) {            if ( cur.children[c-'a'] == null )                cur.children[c-'a'] = new Trie();                        cur = cur.children[c-'a'];        }                cur.word = str;    }}class Solution {    public List&lt;String&gt; findWords(char[][] board, String[] words) {        Trie trie = new Trie();                for( String word : words ) {            trie.insert(word);        }                List&lt;String&gt; result = new ArrayList&lt;&gt;();                for(int i=0;i&lt;board.length;i++)            for(int j=0;j&lt;board[0].length;j++)                search(board, i, j, trie, result);        return result;    }           void search(char[][] board, int i, int j, Trie trie, List&lt;String&gt; result) {        if ( i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == '@' || trie.children[board[i][j]-'a'] == null )            return;                trie = trie.children[board[i][j]-'a'];        if ( trie == null )            return;                if ( trie.word != null ) {            result.add(trie.word);            trie.word = null;        }                char c = board[i][j];        board[i][j]='@';        //임의의 값으로 치환하자. 이미 방문 했다는 의미이다.        search(board, i-1,j, trie, result);        search(board, i+1,j, trie, result);        search(board, i,j-1, trie, result);        search(board, i,j+1, trie, result);        board[i][j]=c;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/word_search_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-what-is-recursion-html": {
        "title": "What is Recursion",
        "tags": "LeetCode, Article",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "Definition문제를 풀기 위한 접근방법중 하나로서, 함수 자기자신을 서브루틴 처럼 호출 하는 방식Keywodbase case : 추가적인 재귀호출없이 바로 결과를 연산해 내는 case, 재귀 호출의 가장 마지막 단계를 수행하는 호출.recurrence relation : 문제의 결과와 하위 문제들의 관계, base case에 도달 하기 위한 규칙ExamplePascal's Triangle이 재귀 호출의 기본적인 예시가 될 수 있다.Pascal's Triangle은 삼각형 모양을 이루게 하는 숫자의 배열인데, 각 로우의 첫번째와 마지막번째의 숫자는 항상 1이고, 그 사이에있는 숫자들은 이전 로우의 바로 위에 있는 숫자와 그 앞 숫자의 합이다.recurrence relationPascal's Triangle에서 i번째 로우의 j번째에 있는 숫자를 산출해 내는 함수 f(i,j)가 있다고 하자.이때 다음의 수식을 이용해서 recurrence relation을 표현 할 수 있다.f(i, j) = f(i - 1, j - 1) + f(i - 1, j)base case우측끝 과 좌측끝에 해당하는것들이 base case이다. 다음과 같은 수식이 된다.f(i,j) = 1 where j = 1 or j = iMemoization재귀를 하다보면 중복 연산을 하게 되는 경우가 발생한다. 예를 들어 Fibonacci number같은 경우 다음과 같은 수식으로 구할 수 있다.f(0) = 0, f(1) = 1n! = f(n) = f(n-1) + f(n-2)그래서 다음 예시로 중복 연산이 발생한다는것을 알 수 있다.f(4) = f(3) + f(2) = (f(2) + f(1)) + f(2)위 식 처럼 f(2)에 대한 연산이 2번 발생한다. 이렇게 되면 우린 이미 f(2)에 대한 연산을 한번 했는데, 한번 더 함으로써불필요한 연산을 더 하게 된다. 위 예시는 4에 대한 예시라서 그렇지 만약 숫자가 더 커지면 중복 연산은 미친듯이 많이 발생한다.중복 연산을 방지하기 위해선 한번 연산했던것에 대한 저장이 필요하다. 그것을 해결하기 위한 방법중 하나로 Memoization을 도입한다.Memoization은 중간 결과값을 메모리에 저장하고 있는것으로 특정 Input에 의한 값을 저장 함으로써 다음에 동일한 Input이 왔을땐 연산을 하기 보단 저장해 놨던 값을반환 하는 식으로 처리 한다.if ( n is cached ) {    return cached result}return f(n-1) + f(n-2)",
        "url": "http://localhost:4000//leetcode/2020/02/03/what_is_recursion.html"
      }        
      ,
    
      "leetcode-2020-02-03-what-is-quick-sort-html": {
        "title": "What is Quick Sort",
        "tags": "LeetCode, Article",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "Definition이름 처럼 빠른 정렬 방식이고, Merge Sort에 비해 2~3배 빠르다.Flow  주어진 리스트를 2개로 나눌 pivot 값을 선정 한다. 하나의 서브 리스트에는 pivot 보다 작은 값들로만 구성되고, 다른 서브리스트에는 pivot과 동일하거나 큰 값으로 구성 한다. 이렇게 나누는 작업을 partitioning 이라 한다. pivot 값을 선정 하는 방식은 주어진 리스트의 첫번째 인자를 사용하거나, 랜덤하게 선택 하면 된다.  partitioning 이후 재귀저그로 2개의 서브 리스트를 정렬 한다.  정렬된 2개의 서브리스트를 합치기만 하면 끝난다.Implements  pivot은 가장 마지막 원소로 설정  [1,5,3,2,8,7,6,4] 리스트에서 pivot을 선정, 리스트의 가장 마지막 값인 4로 설정  partitioning 수행, pivot을 기준으로 작은 값들을 한쪽으로 몰고, 큰 쪽을 반대 쪽으로 몰자. 리스트의 시작 index 부터 비교해 나가면서 pivot 보다 작은게 나올수록 마지막으로 이동했던 index에 있는 값과 위치 변경하고 index를 증가.  모든 비교가 끝나면 pivot의 값과 마지막으로 이동한 index의 값과 위치 변경  모든 서브 리스트를 돌때 까지 2~3번 작업 반복1차 수행[1,5,3,2,8,7,6,4], pivot = 4&gt; 5 와 3 스왑 =&gt; [1,3,5,2,8,7,6,4]&gt; 5 와 2 스왑 =&gt; [1,3,2,5,8,7,6,4]&gt; 5 와 4 스왑 =&gt; [1,3,2,4,8,7,6,5]partitioning 종료, 기준 index = 3index 0~2 까지 정렬 수행index 4~7 까지 정렬 수행public class Solution {  public void quickSort(int [] lst) {   /* Sorts an array in the ascending order in O(n log n) time */    int n = lst.length;    qSort(lst, 0, n - 1);  }  private void qSort(int [] lst, int lo, int hi) {    if (lo &lt; hi) {      int p = partition(lst, lo, hi);      qSort(lst, lo, p - 1);      qSort(lst, p + 1, hi);    }  }  private int partition(int [] lst, int lo, int hi) {    /*      Picks the last element hi as a pivot      and returns the index of pivot value in the sorted array */    int pivot = lst[hi];    int i = lo;    for (int j = lo; j &lt; hi; ++j) {      if (lst[j] &lt; pivot) {        int tmp = lst[i];        lst[i] = lst[j];        lst[j] = tmp;        i++;      }    }    int tmp = lst[i];    lst[i] = lst[hi];    lst[hi] = tmp;    return i;  }}참조  한글 좋아",
        "url": "http://localhost:4000//leetcode/2020/02/03/what_is_quick_sort.html"
      }        
      ,
    
      "leetcode-2020-02-03-what-is-devide-and-conquer-html": {
        "title": "What is Devide and Conquer",
        "tags": "LeetCode, Article",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "Definition재귀의 형태로 구현되는데 2개 이상의 작은 형태로 분할 해서 해결하는 방식Flow  Divide : 문제  를 다음과 같이 여러개의 서브 문제로 분할 한다.   Conquer : 재귀적으로 서브 문제들을 해결한다.  Combine : 각 서브 문제들의 결과 값을 합친다.",
        "url": "http://localhost:4000//leetcode/2020/02/03/what_is_devide_and_conquer.html"
      }        
      ,
    
      "leetcode-2020-02-03-validate-binary-search-tree-html": {
        "title": "Validate Binary Search Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node’s key.  The right subtree of a node contains only nodes with keys greater than the node’s key.  Both the left and right subtrees must also be binary search trees.Example 1:    2   / \\  1   3Input: [2,1,3]Output: trueExample 2:    5   / \\  1   4     / \\    3   6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node's value is 5 but its right child's value is 4.My Answer  현재 노드가 Null이라면 true  현재 노드의 값이 최소값과 최대값 사이에 있는지 확인해야 한다.  자식 노드가 없다면 true  재귀를 이용해서 왼쪽과 오른쪽의 검증도 수행  오른쪽의 최소 값은 현재 노드의 값이다. BST의 오른쪽 노드는 현재 노드의 값보다 커야 하기 때문  왼쪽의 최대 값은 현재 노드의 값이다. BST의 왼쪽 노드는 현재 노드의 값보다 작아야 하기 때문/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean isValidBST(TreeNode root) {        return isValidBST(root, null, null);    }        boolean isValidBST(TreeNode node, Integer min, Integer max ) {        if ( node == null )            return true;                int val = node.val;        if (min != null &amp;&amp; val &lt;= min)            return false;                if (max != null &amp;&amp; val &gt;= max)            return false;        if ( node.left == null &amp;&amp; node.right == null )            return true;                if (! isValidBST(node.right, val, max))            return false;                if (! isValidBST(node.left, min, val))            return false;                    return true;            }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/validate_binary_search_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-valid-sudoku-html": {
        "title": "Valid Sudoku",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition.  Each column must contain the digits 1-9 without repetition.  Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.Example 1:Input:[  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]Output: trueExample 2:Input:[  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being     modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.Note :  A Sudoku board(partially filled) could be valid but is not necessarily solvable.  Only the filled cells need to be validated according to the mentioned rules.  The given board contain only digits 1-9 and where empty cells are filled with the character '.'.  The given board size is always 9x9.  My Answer  HashMap을 이용하자. HashMap의 키는 다음과 같이 선정된다.          row_1~9, column_1~9, block_1~9      코드에선 키 생성을 편하게 하기 위해서 숫자 범위로 한다.      row = [0~height-1] = [0~8]      column = [height~height+width-1] = [9~17]      block = [height+width~height+width+width-1] = [18~26]        HashMap의 값은 Board의 문자가 된다.  Board를 순회 하면서, 현재 위치의 row, column, block의 키를 구하고, 각 키에 대응되는 값에 현재 문자가 포함되어 있는지 확인한다.  만약 포함되어 있다면, 중복 이기때문에 false  포함되어 있지 않다면, 현재 문자를 HashMap의 값에 넣는다.class Solution {    public boolean isValidSudoku(char[][] board) {        Map&lt;Integer, List&lt;Character&gt;&gt; hashmap = new HashMap&lt;&gt;();                int width = board[0].length;        int height = board.length;                for(int i=0;i&lt;height;i++) {            for(int j=0;j&lt;width;j++) {                char c = board[i][j];                if ( c == '.') continue;    //빈 공간은 체크할 필요 없다                //#region Row Check                int row = i;                                                if ( !hashmap.containsKey(row) ) {                    List&lt;Character&gt; l_row = new ArrayList&lt;&gt;();                    hashmap.put(row, l_row);                }                                if ( hashmap.get(row).contains(c) ) return false;                hashmap.get(row).add(c);                //#endregion                //#region Column Check                int column = height + j;                                if ( !hashmap.containsKey(column) ) {                    List&lt;Character&gt; l_column = new ArrayList&lt;&gt;();                    hashmap.put(column, l_column);                }                                if ( hashmap.get(column).contains(c) ) return false;                hashmap.get(column).add(c);                //#endregion                                //#region Block Check                int block = height + width + (i/3*3 + j/3);                if ( !hashmap.containsKey(block) ) {                    List&lt;Character&gt; l_block = new ArrayList&lt;&gt;();                    hashmap.put(block, l_block);                }                                if ( hashmap.get(block).contains(c) ) return false;                hashmap.get(block).add(c);                //#endregion            }        }                    return true;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/valid_sudoku.html"
      }        
      ,
    
      "leetcode-2020-02-03-valid-perfect-square-html": {
        "title": "Valid Perfect Square",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a positive integer num, write a function which returns True if num is a perfect square else False.Example 1:Input: 16Output: trueExample 2:Input: 14Output: falseNote:Do not use any built-in library function such as sqrt.My Answer  특정 수의 제곱수 인지 확인 하는 문제.  low, high의 중간값 mid를 구한다.  num을 mid로 나눈값이 mid보다 작을 경우엔 num의 제곱근이 mid보다 크다는 것이기 때문에, low를 mid+1값으로 할당한다.  num을 mid로 나눈값이 mid보다 클 경우엔 num의 제곱근이 mid보다 작다는 것이기 때문에, high를 mid-1값으로 할당한다.  최종적으로 low는 num의 제곱근이거나, 가장 가까운 수가 된다.class Solution {    public boolean isPerfectSquare(int num) {        int low=1;        int high=num;                while(low &lt;= high) {            int mid = low + ((high-low)/2);                        if ( mid &lt; num/mid) {                low=mid+1;            } else {                high=mid-1;            }        }                return low*low == num;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/valid_perfect_square.html"
      }        
      ,
    
      "leetcode-2020-02-03-unique-bst-ii-html": {
        "title": "Unique Binary Search Trees II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.Example :Input: 3Output:[  [1,null,3,2],  [3,2,null,1],  [3,1,null,null,2],  [2,1,3],  [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST's shown below:   1         3     3      2      1    \\       /     /      / \\      \\     3     2     1      1   3      2    /     /       \\                 \\   2     1         2                 3My Answer  Binary Search Tree는 Parent Node 보다 작은수가 왼쪽 큰 수가 오른쪽으로 위치한다.  작은 수에서 큰수로 반복 돌면서 좌, 우를 재귀로 구성./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;TreeNode&gt; generateTrees(int n) {        if ( n &lt; 1 ) {            return new ArrayList&lt;TreeNode&gt;();        }                return generator(1, n);    }        List&lt;TreeNode&gt; generator(int low, int high ) {        List&lt;TreeNode&gt; result = new ArrayList&lt;TreeNode&gt;();        if ( low &gt; high ) {                        result.add(null);            return result;        }                for(int n=low; n &lt;= high; n++) {            List&lt;TreeNode&gt; left_tree = generator(low, n -1);            List&lt;TreeNode&gt; right_tree = generator(n+1, high);                        for(TreeNode l : left_tree) {                for(TreeNode r : right_tree ) {                    TreeNode root = new TreeNode(n);                    root.left = l;                    root.right = r;                    result.add(root);                }            }        }                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/unique_bst_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-two-sum-ii-input-array-sorted-html": {
        "title": "Two Sum II - Input array is sorted",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.Example 1:Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.Note:  Your returned answers (both index1 and index2) are not zero-based.  You may assume that each input would have exactly one solution and you may not use the same element twice.My Answer  l, r은 각각 왼쪽 index, 오른쪽 index를 의미 한다.  numbers[l]과 numbers[r]의 합(sum)이 target과 동일하면 정답이다.  만약 sum이 target보다 크다면, r을 하나 감소 시키자.  만약 sum이 target보다 작다면, l을 하나 증가 시키자.class Solution {    public int[] twoSum(int[] numbers, int target) {        int l=0;        int r=numbers.length-1;                int[] result = new int[2];                while( l &lt; r ) {            int sum = numbers[l] + numbers[r];            if ( sum == target ) {                result[0] = l+1;                result[1] = r+1;                break;            }                        if ( sum &gt; target ) {                r--;            } else {                l++;            }        }                return result;    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/two_sum_ii_input_array_sorted.html"
      }        
      ,
    
      "leetcode-2020-02-03-two-sum-html": {
        "title": "Two Sum",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example :Input: [2, 7, 11, 15], target = 9Output: [0, 1]Explanation: nums[0] + nums[1] = 2 + 7 = 9My Answer  HashMap을 이용하자.  nums를 순회하면서, target을 만들 수 있는 값을 찾자.  target-nums[i]가 nums[i]를 이용해서 target을 만들 수 있는 값이고, 이것이 HashMap에 있다면 정답.class Solution {    public int[] twoSum(int[] nums, int target) {                Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement)) {                return new int[] { map.get(complement), i };            }            map.put(nums[i], i);        }                return null;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/two_sum.html"
      }        
      ,
    
      "leetcode-2020-02-03-symmetric-tree-html": {
        "title": "Symmetric Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).Example 1:    1   / \\  2   2 / \\ / \\3  4 4  3Input: [1,2,2,3,4,4,3]Output: trueExample 2:    1   / \\  2   2   \\   \\   3    3Input: [1,2,2,null,3,null,3]Output: falseMy Answer ( Recursive )  재귀를 이용해서 해결  isMirror 함수를 이용해서 확인  t1 과 t2 둘 다 null 이라면 true  t1 과 t2 둘 중에 하나만 null 이라면 false  둘 다 null이 아닐땐, 둘다 값이 동일 하고 재귀 호출로 t1.right, t2.left를 확인하고, t1.left, t2.right를 확인해서 결정/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean isSymmetric(TreeNode root) {        return isMirror(root, root);    }        public boolean isMirror(TreeNode t1, TreeNode t2) {        if (t1 == null &amp;&amp; t2 == null) return true;        if (t1 == null || t2 == null) return false;        return (t1.val == t2.val)            &amp;&amp; isMirror(t1.right, t2.left)            &amp;&amp; isMirror(t1.left, t2.right);    }}My Answer ( Iteration )  반복문을 이용해서 해결  Queue에 2개씩 넣고 조건에 맞춰서 비교 하자./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean isSymmetric(TreeNode root) {        if ( root == null )            return true;                Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();                q.add(root);        q.add(root);                while(!q.isEmpty()) {            TreeNode t1 = q.poll();            TreeNode t2 = q.poll();                        if ( t1 == null &amp;&amp; t2 == null )                continue;                        if ( t1 == null || t2 == null )                return false;                        if ( t1.val != t2.val )                return false;                        q.add(t1.left);            q.add(t2.right);            q.add(t1.right);            q.add(t2.left);        }                return q.isEmpty();    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/symmetric_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-sudoku-solver-html": {
        "title": "Sudoku Solver",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWrite a program to solve a Sudoku puzzle by filling the empty cells.A sudoku solution must satisfy all of the following rules:Each of the digits 1-9 must occur exactly once in each row.Each of the digits 1-9 must occur exactly once in each column.Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.Empty cells are indicated by the character ‘.’.Note:  The given board contain only digits 1-9 and the character ‘.’.  You may assume that the given Sudoku puzzle will have a single unique solution.  The given board size is always 9x9.My Answer  BackTracking을 이용해서 해결  넣을 수 있는 문자 1~9를 배열로 미리 선언해 놓는다.  solver를 재귀로 호출, solver를 재귀로 호출 한 이후 결과값이 false이면 이번에 넣었던 숫자는 맞지 않는다는 의미이기 때문에 .으로 설정한다.  isValid 함수에서 현재 넣으려는 Row, Column 그리고 숫자를 이용해서 스도쿠의 규칙에 위배 되지 않는지를 검증한다.class Solution {    char[] candidate = {'1','2','3','4','5','6','7','8','9'};        public void solveSudoku(char[][] board) {        solver(board);    }        boolean solver(char[][] board){                   boolean is_empty = false;        int next_row = -1;        int next_col = -1;                for(int row = 0; row &lt; 9; row++) {            for(int col = 0; col &lt; 9; col++) {                if ( board[row][col] == '.') {                    is_empty = true;                    next_row = row;                    next_col = col;                    break;                }                                }                        if ( is_empty )                break;        }                if ( !is_empty ) {            return true;        }                for(char number : candidate ) {                if ( isValid(board, next_row, next_col, number)) {                board[next_row][next_col] = number;                if ( solver(board) ) {                    return true;                } else {                    board[next_row][next_col] = '.';    //재귀 호출 이후 결과값이 false가 나왔다는 것은 다른 숫자를 넣어야 한다는것이니 빈값으로 설정                }            }        }                return false;    }        boolean isValid(char[][] board, int cur_row, int cur_col, char number) {        for(int col = 0; col &lt; 9; col++) {      //현재 Row에 number와 중복된 숫자가 있는지 확인            if ( board[cur_row][col] == number )                return false;        }                for(int row = 0; row &lt; 9; row++) {      //현재 Column에 number와 중복된 숫자가 있는지 확인            if ( board[row][cur_col] == number )                return false;        }                int start_row = getStartIndex(cur_row);        int start_col = getStartIndex(cur_col);                for(int row = start_row; row &lt; start_row +3; row++) {       //현재 Row와 Column이 속해 있는 3x3 영역에 중복된 숫자가 있는지 확인            for(int col = start_col; col &lt; start_col +3; col++) {                if ( board[row][col] == number )                    return false;            }        }                return true;    }        int getStartIndex(int target) {        if ( target &lt; 3 ) {            return 0;        } else if ( target &lt; 6 ) {            return 3;        } else {            return 6;        }                }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/sudoku_solver.html"
      }        
      ,
    
      "leetcode-2020-02-03-sqrt-html": {
        "title": "Sqrt(x)",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemImplement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since              the decimal part is truncated, 2 is returned.My Answer  소숫점은 알 필요 없으니까 제곱수 중에서 가장 가까운 정수를 구하면 된다.  l은 타겟 까지의 작은 수, r은 타겟 까지의 가장 가까운 큰 수이다.  while문에서는 l + r한 값을 오른쪽 쉬프트해서 중간 값을 찾는다. 예를 들어 다음과 같이 계산 된다.      l = 0 = 0000, r = 7 = 0111;  l+r = 7 = 0111  l+r &gt;&gt; 1 = 3 = 0011  l = 1 = 0001, r = 9 = 1001;  l+r = 10 = 1010  l+r &gt;&gt; 1 = 5 = 0101        중간값을 제곱한것이 x와 같으면 정답이고, 만약 x보다 작다면, 더 큰 중간값을 찾아야 한다는 의미이기때문에, l을 증가시키고, x보다 크다면 r을 감소 시키면 된다.class Solution {    public int mySqrt(int x) {        if (x &lt; 0) return -1;        int l = 0;        int r = x;        while (l &lt;=r) {            int mid = (l+r)&gt;&gt;1;            long midVal = (long) mid * mid;            if (midVal == x) return mid;            if (midVal &lt; x) {                l = mid + 1;            } else {                r = mid - 1;            }        }        return r;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/sqrt.html"
      }        
      ,
    
      "leetcode-2020-02-03-split-array-largest-sum-html": {
        "title": "Split Array Largest Sum",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.Example :Input:nums = [7,2,5,10,8]m = 2Output:18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18.Note:If n is the length of array, assume the following constraints are satisfied.                My Answer  중간값을 이용해서 해결  l, r은 각각 subarray의 최대 값과, 전체 배열의 최대값을 의미 한다.  만약 m==1 이라면, 전체 배열을 의미 하니까 r이 정답.  만약 m==nums.length 라면, 원소 하나하나가 subarray라는 의미니까 l이 정답.  m으로 분할한 각 subarray의 총합(s)의 범위는 이 되고, 이중 m으로 분할되면서 작은 값을 찾으면 된다. 위 예제를 다음과 같은 흐름으로 찾을 수 있다.      nums = [7,2,5,10,8], m = 2  l=10, r=7+2+5+10+8=32, s=10~32      1:      mid=(10+32)/2=21            [7,2,5][10,8]      subarray 갯수가 7+2+5 에서 1, 10+8 에서 2가 되면서 subarray의 합이 21이 안되기 때문에      r=21  2:      mid=(10+21)/2=15      [7,2,5][10][8]      subarray 갯수가 7+2+5 에서 1, 10에서 2, 8에서 3이 되면서 m 보다 커져서      l=16  3:      mid=(16+21)/2=18      [7,2,5][10,8]      subarray 갯수가 7+2+5 에서 1, 10+8 에서 2가 되면서 subarray의 합이 18이 안되기 때문에      r=18  4:      mid=(16+18)/2=17      [7,2,5][10,8]      subarray 갯수가 7+2+5 에서 1, 10에서 2, 8에서 3이 되면서 m 보다 커져서      l=18  l과 r이 동일해 졌기 때문에, 반복 종료 정답은 18               class Solution {    public int splitArray(int[] nums, int m) {        int l = 0;        int r = 0;                for(int n : nums) {            l = Math.max(l, n);            r += n;        }                if ( m == 1 )            return r;                if ( nums.length == m )            return l;                while ( l &lt; r ) {            int mid = (l+r)/2;                        if ( canSplit(nums, m, mid)) {                r = mid;            } else {                l = mid + 1;            }        }                return l;    }        boolean canSplit(int[] nums, int m, int max ) {        int split_count = 1;        int sum = 0;                for(int n : nums ) {            sum += n;                        if ( sum &gt; max ) {                sum = n;                split_count++;                                if ( split_count &gt; m ) {                    return false;                }            }        }                return true;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/split_array_largest_sum.html"
      }        
      ,
    
      "leetcode-2020-02-03-sort-an-array-html": {
        "title": "Sort an Array",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers nums, sort the array in ascending orderExample 1:Input: nums = [5,2,3,1]Output: [1,2,3,5]Example 2:Input: nums = [5,1,1,2,0,0]Output: [0,0,1,1,2,5]Constraints1 &lt;= nums.length &lt;= 50000-50000 &lt;= nums[i] &lt;= 50000My Answer  Divide and Conquer에 충실하게 작성  Sort함수에서 정렬과 중간 index를 이용해서 left, right 리스트를 나눠서 따로 정렬 하도록 한다.  마지막에 하나의 리스트에 정렬된 리스트를 다시 정렬해서 넣는다.  미친듯이 List&lt;Integer&gt; 객체를 만들어 내서 문제가 많다.class Solution {    public List&lt;Integer&gt; sortArray(int[] nums) {        if ( nums == null || nums.length == 0 )            return null;                List&lt;Integer&gt; l_nums = new ArrayList&lt;Integer&gt;(nums.length);        for(int i : nums) {            l_nums.add(i);        }                List&lt;Integer&gt; result = Sort(l_nums);                return result;    }        List&lt;Integer&gt; Sort(List&lt;Integer&gt; list) {        int length = list.size();                if ( length == 1) {            return list;        }                int pivot = length / 2;        List&lt;Integer&gt; l_left = Sort(list.subList(0, pivot));        List&lt;Integer&gt; l_right = Sort(list.subList(pivot, length));                int l=0,r=0;        int left_count = l_left.size();        int right_count = l_right.size();                        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(length);                while (l &lt; left_count || r &lt; right_count ) {            int left = Integer.MAX_VALUE;            int right = Integer.MAX_VALUE;                        if ( l &lt; left_count ) {                left = l_left.get(l);            }                        if ( r &lt; right_count ) {                right = l_right.get(r);            }                        if ( left &lt; right ) {                result.add(left);                l++;            } else {                result.add(right);                r++;            }                    }                return result;    }}Fastest Answer ( Not D&amp;C )  Devide and Conquer 방식을 사용하지 않고 문제에 충실했다.  문제의 제약조건에 의해서 nums[i]에 들어갈수 있는 수는 -50000 ~ 50000 이기 때문에, 100001개의 배열을 만들어서 nums[0] = -50000을 의미 할 수있도록 했다.class Solution {    public List&lt;Integer&gt; sortArray(int[] nums) {        int[] count = new int[100001];                for (int i: nums) {            count[i+50000]++;       //정렬되지 않은 배열을 만들면서 i=nums[x] 에다가 50000을 더한다. 그리고 발생횟수를 증가 시킨다.        }                List&lt;Integer&gt; result = new ArrayList&lt;&gt;();           for (int i=0; i&lt;count.length; i++) {    //100001번 순회 한다.                        while(count[i]&gt;0) { //동일한 값이 반복해서 들어가 있을 수 있기때문에, 현재 값이 0이 될때 까지 돈다.                result.add(i - 50000); //nums에 있던 값을 50000 더해서 변형해 줬기 때문에, 다시 원상 복귀 시켜서 결과 리스트에 넣어 준다.                count[i]--;            }                     }                return result;    }}Fastest Answer ( Use D&amp;C )  Devide and Conquer에 충실했다.class Solution {    public List&lt;Integer&gt; sortArray(int[] nums) {        sort(nums, 0, nums.length - 1);        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();                for (int num : nums) {            result.add(num);        }                return result;    }        private void sort(int[] nums, int lo, int hi) {        if (lo &gt;= hi) {            return;        }                int pIdx = partition(nums, lo, hi);                sort(nums, lo, pIdx - 1);        sort(nums, pIdx + 1, hi);    }        private int partition(int[] nums, int start, int end) {        if (start &gt;= end) {            return start;        }                int pivot = nums[start];                int j = start + 1;                for (int i = start + 1; i &lt;= end; i++) {            if (nums[i] &lt; pivot) {                swap(nums, j++, i);            }        }                swap(nums, start, j - 1);                return j - 1;    }        private void swap(int[] nums, int i, int j) {        int tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/sort_an_array.html"
      }        
      ,
    
      "leetcode-2020-02-03-skyline-problem-html": {
        "title": "The Skyline Problem",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemA city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). Buildings Skyline ContourThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].Notes  The number of buildings in any input list is guaranteed to be in the range [0, 10000]  The input list is already sorted in ascending order by the left x position Li  The output list must be sorted by the x position  There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]My Answer  알고리즘은 다음과 같다.          x좌표대로 진행 하면서, 높이 차가 발생할때 마다 결과 리스트에 넣으면 된다.      예제 처럼 [2 9 10] 일때 2개의 좌표가 나온다. [[2 10], [9 10]] 앞의 좌표는 빌딩의 시작 좌표이고, 뒤의 좌표는 빌딩의 끝 좌표 이다.              [3 7 15]까지 추가 되면 [[2 10], [9 10], [3 15], [7 15]]가 된다. 이걸 그림으로 표현 하면 다음과 같다.                          빨간 점은 결과 리스트에 들어가야한 좌표들 [[2 10], [3 15], [7 10], [9 0]]                    위 그림에서 보듯이 결과 리스트에 들어가야하는 것들은 높이 차가 발생할때 라는것을 알 수 있다.      높이 차가 발생했다 라는것을 알기 위해서, 기존의 최대 높이 prev_max_h 와 현재 좌표 입장에서의 최대 높이 curr_max_h, 그리고 지금까지 거쳐왔던 높이들을 저장할 데이터 스트럭쳐 queue_h가 필요 하다.      처음 prev_max_h를 0으로 해서 좌표를 순회 하면서, 좌표가 빌딩의 시작 좌표인 경우엔 queue_h에 현재 높이 를 넣고, curr_max_h에는 queue_h에 있는 높이들중 가장 큰 값을 할당한다.      만약 prev_max_h와 curr_max_h가 다르다면, 높이차가 발생한 것이니 결과 리스트에 추가 하면 되는데, [현재 x, curr_max_h] 형태로 추가하고, 6~7번을 반복한다.      [[2 10], [9 10], [3 15], [7 15]]의 경우 다음과 같은 흐름이 된다.                  현재 좌표 = [2 10], prev_max_h = 0, queue_h = [0, 10], curr_max_h = 10          prev_max_h와 curr_max_h가 다르기 때문에, 결과 리스트에 [현재 x, curr_max_h] = [2 10] 추가          prev_max_h에 curr_max_h 할당. prev_max_h = 10          다음 좌표로 반복 수행                    6번 내용을 수행하기 이전에 정렬을 해줘야 한다. x좌표에 따라 순차 대로 진행 해야 하기 때문에, [[2 10],[3 15],[7 15],[9 10]]로 6번을 시작 해야 한다.        각 x좌표에 따른 높이 값을 저장하는 구조체 Point를 만들자.  x좌표 별로 building의 Li에 해당 하면 isStart를 true로 하고, Ri에 해당 하면 isStart를 false로 하자.  총 생성되는 Point의 갯수는 building의 갯수 x 2가 되고, points 배열에 저장하자.  points를 정렬 한다, 이때 정렬 조건은 다음과 같다.          x 좌표가 다르다면 x값이 작은것 우선      isStart가 true라면 높이가 큰 것 우선, isStart가 false라면 높이가 작은 것 우선        points를 순회 하면서, 높이들을 저장하면서, 높이가 큰 순서 대로 정렬될 PriorityQueue를 준비 한다.  현재 Point가 isStart라면 PriorityQueue에 넣고, 아니라면 뺀다.  PriorityQueue의 제일 앞에 있는 값, 즉 높이가 가장 높은것을 가져온 후, 이전 순회에서 결정된 높이값과 비교해서, 다르다면 결과 리스트에 추가class Solution {    private class Point implements Comparable&lt;Point&gt;{        int x;        int height;        boolean isStart;                public Point(int x, int height, boolean isStart) {            this.x = x;            this.height = height;            this.isStart = isStart;        }                public int compareTo(Point p) {            if (this.x != p.x) {    //x가 다른건 볼것도 없다, x값이 작은것을 우선하자.                return this.x - p.x;            } else {                //x가 동일 하다면, this와 p가 isStart라면 높이가 큰것을 우선으로 하고, 아니라면 높이가 작은것을 우선 하자.                return (this.isStart ? -this.height : this.height) - (p.isStart ? -p.height : p.height);                      }        }    }        public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        int total_count = buildings.length;        if ( total_count == 0 ) {            return result;        }                Point[] points = new Point[total_count * 2];        int i = 0;                for( int[] building : buildings ) { //building 하나 [Li, Ri, Hi]를 이용해서 2개의 Point를 만들자, [Li, Hi, true], [Ri, Hi, false]            points[i++] = new Point(building[0], building[2], true);                   points[i++] = new Point(building[1], building[2], false);        }                Arrays.sort(points);    //정렬을 반드시 해줘야 한다.                PriorityQueue&lt;Integer&gt; height_queue = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());   //순회돌면서, 거쳐간 Point의 높이 값을 저장하고, 값이 큰 순서대로 저장할 Queue        height_queue.add(0);    //기본 높이 0을 넣어 주자.                int prev_max_height = 0;        for( Point point : points ) {            if ( point.isStart ) {      //시작 좌표라면 현재 Point의 높이의 시작이니까 넣어 주고, 끝 좌표라면 현재 높이는 처리 했다는 의미니까 빼주자.                height_queue.add(point.height);            } else {                height_queue.remove(point.height);            }                        int current_max_height = height_queue.peek();                        if ( prev_max_height != current_max_height ) {      //이전 최고 높이와 현재 최고 높이가 다르다는것은 높이차가 발생했다. 결과 리스트에 추가 하자.                result.add(Arrays.asList(point.x, current_max_height));                prev_max_height = current_max_height;            }        }        return result;    }   }Fastest Answerclass Solution {    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) {        List&lt;List&lt;Integer&gt;&gt; keyPoints = new ArrayList&lt;&gt;();        int lastLowXIdx = -1;        for (int[] building : buildings){            int li = building[0];            int ri = building[1];            int hi = building[2];            lastLowXIdx = insertBuilding(li, ri, hi, keyPoints, lastLowXIdx);        }        return keyPoints;    }    protected int insertBuilding(int li, int ri, int hi, List&lt;List&lt;Integer&gt;&gt; keyPoints, int lastLowXIdx){        int nextIdx = keyPoints.size();        for (int i = lastLowXIdx + 1; i &lt; keyPoints.size(); i++){   //기존의 결과리스트에 있는것들 중에서 현재 빌딩의 Li 보다 큰 x인것을 찾는다. 왜냐하면, 결과 리스트를 x값으로 정렬되어야 하기 때문.            if (keyPoints.get(i).get(0) &gt; li){                nextIdx = i;                break;            }        }        int currIdx = nextIdx - 1;  //좌표가 들어갈 결과 리스트의 index        int oldHight = currIdx &gt;= 0 ? keyPoints.get(currIdx).get(1) : 0;    //기존 결과 리스트에 있던 높이        int currentHigh = oldHight;        if (hi &gt; oldHight){ //현재 빌딩의 높이가 기존 결과 리스트에 있던 높이 보다 크고            if (currIdx &lt; 0 || keyPoints.get(currIdx).get(0) &lt; li) {    //현재 index가 0보다 작거나 ( 결과 리스트가 비어 있었다 ), x가 li보다 작다면 결과 리스트에 추가.                keyPoints.add(currIdx + 1, makeKeyPoint(li, hi));                currentHigh = hi;                currIdx++;            } else {    //x가 li와 같다. 즉 같은 빌딩의 시작 위치가 동일한데, 높이가 다르다.                if (currIdx &gt;= 1 &amp;&amp; keyPoints.get(currIdx - 1).get(1) == hi){   //넣어야 할 위치 이전 결과 리스트의 값의 높이가 현재 높이와 동일하다. ???????                    keyPoints.remove(currIdx);                    currIdx--;                    currentHigh = hi;                } else {    //높이만 다시 갱신해 주자.                    keyPoints.get(currIdx).set(1, hi);                    currentHigh = hi;                }            }        } else {            currentHigh = oldHight;        }        lastLowXIdx = currIdx;        currIdx ++;        while (currIdx &lt; keyPoints.size() &amp;&amp; keyPoints.get(currIdx).get(0) &lt; ri){   //기존의 결과 리스트의 x값들 중, Ri보다 작은것들, 즉 현재 빌딩이 추가 됨으로 인해서 없어져야 하거나, 높이 갱신이 필요한것들 처리            oldHight = keyPoints.get(currIdx).get(1);            if (hi &gt;= oldHight){                if (currentHigh == hi){                    keyPoints.remove(currIdx);                    currIdx--;                } else {                    keyPoints.get(currIdx).set(1, hi);                        currentHigh = hi;                }            } else {                currentHigh = oldHight;            }            currIdx ++;        }        if (hi &gt; oldHight &amp;&amp; currentHigh != oldHight){            if (currIdx &gt;= keyPoints.size() || keyPoints.get(currIdx).get(0) &gt; ri) {                keyPoints.add(currIdx, makeKeyPoint(ri, oldHight));                currentHigh = oldHight;            }        }        return lastLowXIdx;    }    protected List&lt;Integer&gt; makeKeyPoint(int x, int y){        List&lt;Integer&gt; keyPoint = new ArrayList&lt;&gt;(2);        keyPoint.add(x);        keyPoint.add(y);        return keyPoint;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/skyline_problem.html"
      }        
      ,
    
      "leetcode-2020-02-03-single-number-html": {
        "title": "Single Number",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a non-empty array of integers, every element appears twice except for one. Find that single one.Example 1:Input: [2,2,1]Output: 1Example 2:Input: [4,1,2,1,2]Output: 4My Answer  하나의 값을 제외한 나머지 값이 중복된다는 것을 이용해서 XOR연산을 이용하자.  XOR연산의 특징이 A^A=0, A^0=A 이다.  nums을 순회하면서 XOR연산을 반복하면 중복되지 않는 값만 남는다.class Solution {    public int singleNumber(int[] nums) {        int n = 0;        for(int i : nums) {            n ^= i;        }                return n;            }}My Answer ( Use HashSet )class Solution {    public int singleNumber(int[] nums) {        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();                for ( int n : nums) {            if ( hashSet.contains(n)) {                hashSet.remove(n);            } else {                hashSet.add(n);            }        }                return hashSet.iterator().next();    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/single_number.html"
      }        
      ,
    
      "leetcode-2020-02-03-serialize-deserialize-binarytree-html": {
        "title": "Serialize and Deserialize Binary Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.Example    1   / \\  2   3     / \\    4   5\"[1,2,3,null,null,4,5]\"ClarificationThe above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.Note:Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.My Answer  DFS 방식을 이용하자.  serialize          DFS를 이용해서 다음 depth의 Node를 수집 하면서 순회하자.      현재 depth의 Node를 순회 하면서, null이면 \"null\"을 기록하고 아니라면, value를 기록 하자.      Node가 null이 아니라면, curr_value_count를 하나씩 감소 시키자.      Node의 left or right가 null이 아니라면 child_value_count를 하나씩 증가 시키자.      만약 child_value_count가 0이면 다음 depth는 존재 하지 않는다.      순회가 끝나면, 다음 depth처리를 위해 curr_value_count에 child_value_count의 값을 할당하고, child_value_count는 0으로 할당 하자.        deserialize          문자열의 포멧이 \"[x,y,z....]\" 이기 때문에, 맨 앞과 맨뒤의 문자를 제거하고, \",\"를 이용해서 split해서, splitted배열에 저장하자.      DFS를 이용하자.      현재 Node의 left or right를 구성할 때, splitted에서 가져올 것이 있다면, 가져와서 새로운 TreeNode객체를 만들어서 할당하자.      splitted에서 더이상 가져올 것이 없다면, 전부 구성 했다는 의미니까 종료.      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Codec {    // Encodes a tree to a single string.    public String serialize(TreeNode root) {        if ( root == null )            return \"\";                StringBuilder builder = new StringBuilder();                Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();                builder.append(\"[\");        q.add(root);                int curr_value_count = 0;        int child_value_count = 0;                while(!q.isEmpty()) {                int n = q.size();                        for(int i=0;i&lt;n;i++) {                TreeNode node = q.poll();                if ( n == 1) {                    builder.append(String.format(\"%s\", node == null ? \"null\" : node.val));                } else {                    if ( node != null )                        curr_value_count--;                                        builder.append(String.format(\",%s\", node == null ? \"null\" : node.val));                    }                if ( node == null )                     continue;                                 if ( node.left != null ) {                                                        child_value_count++;                }                if ( node.right != null ) {                    child_value_count++;                }                   q.add(node.left);                q.add(node.right);                                if ( curr_value_count == 0 )                    break;            }                                    if ( child_value_count == 0 )                break;                        curr_value_count = child_value_count;            child_value_count = 0;        }                builder.append(\"]\");                return builder.toString();            }    // Decodes your encoded data to tree.    public TreeNode deserialize(String data) {        if ( data == null || data.isEmpty())            return null;                String values = data.substring(1, data.length() - 1);        String[] splitted = values.split(\",\");        int i = 0;        TreeNode root = new TreeNode(Integer.parseInt(splitted[i++]));                Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);                while ( !q.isEmpty() &amp;&amp; i &lt; splitted.length ) {            int n = q.size();            outerloop:            for(int x=0;x&lt;n;x++) {                TreeNode node = q.poll();                                for(int y=0;y&lt;2;y++) {                    if ( i &gt;= splitted.length)                        break outerloop;                                        String val = splitted[i++];                    try {                        if ( y == 0 ) {                            node.left = new TreeNode(Integer.parseInt(val));                                                 q.add(node.left);                            } else {                            node.right = new TreeNode(Integer.parseInt(val));                                                 q.add(node.right);                            }                                            } catch (NumberFormatException e) {                                            }                                                        }                                       }        }                return root;    }}// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root));",
        "url": "http://localhost:4000//leetcode/2020/02/03/serialize_deserialize_binarytree.html"
      }        
      ,
    
      "leetcode-2020-02-03-search-in-rotated-sorted-array-html": {
        "title": "Search in Rotated Sorted Array",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).Example 1:Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4Example 2:Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1My Answer  O(log n)의 복잡도를 따르기 위해선 배열의 모든 요소를 돌아선 안된다.  배열의 반절씩만 확인하고, 중간값이 찾는 target인지 확인해야 한다.  low는 최소 index를, high는 최대 index를 의미, while문에서는 low와 high의 중간 index (mid)를 이용해서 해당 값이 target과 같은지 확인해서 같으면 끝.  같지 않으면, 오름차순으로 되어 있는 구간을 찾고, 그 구간에 찾는 target이 들어가는지에 따라서, 다음 low와 high가 결정난다.class Solution {    public int search(int[] nums, int target) {        int low = 0;        int high = nums.length - 1;                while (low &lt;= high) {            int mid = low + ((high - low) &gt;&gt; 1);                        if (nums[mid] == target) {                return mid;            }                        if (nums[mid] &lt;= nums[high]) {      //mid ~ high가 오름차순으로 되어 있다.                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) {   //target이 nums[mid]~nums[high]사이에 있는 값이라면 low를 mid+1로 하자.                    low = mid + 1;                } else {                    high = mid - 1;     //target이 nums[mid]~[high]사이에 없다. 그럼 nums[low]~nums[mid-1]사이에 있다는 의미기 때문에 high를 변경 하자.                }            } else {                if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) {                    high = mid - 1;                } else {                    low = mid + 1;                }            }        }        return -1;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/search_in_rotated_sorted_array.html"
      }        
      ,
    
      "leetcode-2020-02-03-search-in-binary-search-tree-html": {
        "title": "Search in a Binary Search Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL.Example :Input:         4       / \\      2   7     / \\    1   3    search : 2Output:       2          / \\       1   3My Answer  BST 이기 때문에 nxt.val과 val의 차이에 따라 nxt혹은 결과가 나온다.  만약 nxt.val이 val보다 작다면, 정답은 nxt의 우측에 있다는 의미  만약 nxt.val이 val보다 크다면, 정답은 nxt의 좌측에 있다는 의미  만약 nxt.val이 val과 같다면, 정답/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode searchBST(TreeNode root, int val) {        TreeNode res = null;        TreeNode nxt = root;                while ( nxt != null ) {            if ( nxt.val == val ) {                res = nxt;                break;            }                            if ( nxt.val &lt; val ) nxt = nxt.right;            else nxt = nxt.left;        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/search_in_binary_search_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-search-for-a-range-html": {
        "title": "Search for a Range",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].Example 1:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]My Answer  searchIndex함수를 이용해서 target과 일치 하는 최소 index(l), target과 일치하는 최대 index(r)을 찾자.  만약 l이 nums.length와 같다는 것은 target을 찾지 못했고, target보다 작은 값들만 있다는 것이고, nums[l]이 target과 다르다는것은 target을 찾지 못했고, 큰 값과 작은 값이 섞여 있었다는 것이다.  위와 같은 상황이 아니라면, r을 찾자.  searchIndex에선 l을 찾을땐 nums[mid] 가 target보다 크거나, 같으면 high를 줄여서 작은 범위에서 더 찾는다.  searchIndex에선 r을 찾을땐 nums[mid] 가 target과 같거나, 작을때 low를 늘려서 큰 범위에서 더 찾는다.  예를 들어 다음과 같은 흐름으로 진행된다.      Input: nums = [5,7,7,8,8,10], target = 8  l:      1:          low=0,high=6,mid=3,nums[mid]=8          left &amp;&amp; nums[mid] == target              high=3      2:          low=0,high=3,mid=1,nums[mid]=7          nums[mid] &lt; target              low=mid+1=2      3:          low=3,high=3, 반복 종료  l이 3이고 nums[3]=8 == target 이기 때문에 r 찾기 수행  r:      1:          low=0,high=6,mid=3,nums[mid]=8          nums[mid] == target              low=mid+1=4      2:          low=4,high=6,mid=5,nums[mid]=10          nums[mid] &gt; target              high=5      3:          low=4,high=5, mid=4, nums[mid]=8          nums[mid] == target              low=mid+1=5      4:          low=5, high=5, 반복 종료  searchIndex의 결과 값이 5인데 여기서 1을빼서 r은 4      class Solution {    public int[] searchRange(int[] nums, int target) {        int[] result = {-1, -1};                int l = searchIndex(nums, target, true);                if ( l == nums.length || nums[l] != target ) {            return result;        }                result[0] = l;        result[1] = searchIndex(nums, target, false) - 1;                return result;    }        int searchIndex(int[] nums, int target, boolean left ) {        int low = 0;        int high = nums.length;                while( low &lt; high ) {            int mid = (low + high)&gt;&gt;1;                        if ( nums[mid] &gt; target || ( left &amp;&amp; nums[mid] == target )) {                high = mid;            } else {                low = mid+1;            }        }                return low;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/search_for_a_range.html"
      }        
      ,
    
      "leetcode-2020-02-03-search-2d-matrix-ii-html": {
        "title": "Search a 2D Matrix II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right.  Integers in each column are sorted in ascending from top to bottom.Example :[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false.My Answer  사전에 이미 정렬이 된 상황이기때문에, 맨 끝에서 부터 찾아 가면 된다.  0번째 row의 맨 마지막 column부터 시작해서, 찾으려는 값과 동일하면 끝. 만약 값이 작다면 그 다음 row를 보고, 값이 크면 이전 column을 보면 됨  무식하게 m x n 만큼돌지 않는다.class Solution {    public boolean searchMatrix(int[][] matrix, int target) {        if (matrix.length == 0)            return false;                int row = 0;        int col = matrix[0].length - 1;                while(row &lt; matrix.length &amp;&amp; col &gt;= 0) {            int val = matrix[row][col];            if ( val == target ) {                return true;            } else if ( val &lt; target ) {                row++;            } else {                col--;            }        }                return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/search_2d_matrix_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-reverse-string-recursively-html": {
        "title": "Reverse String Recursively",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWrite a function that reverses a string. The input string is given as an array of characters char[].Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.You may assume all the characters consist of printable ascii characters.Example 1:Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]Example 2:Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]My Answer  재귀 함수 reverse를 이용해서 처리  base case는 l_idx가 r_idx 보다 커질때 이다. 이경우는 더 이상 스왑할것이 없다는 의미class Solution {    public void reverseString(char[] s) {        reverse(s, 0, s.length - 1);    }        void reverse(char[] s, int l_idx, int r_idx ) {        if ( l_idx &gt; r_idx )            return;                char src = s[l_idx];        char dst = s[r_idx];        s[l_idx] = dst;        s[r_idx] = src;                   reverse(s, ++l_idx, --r_idx);    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/reverse_string_recursively.html"
      }        
      ,
    
      "leetcode-2020-02-03-reverse-string-iteratively-html": {
        "title": "Reverse String Iteratively",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWrite a function that reverses a string. The input string is given as an array of characters char[].Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.You may assume all the characters consist of printable ascii characters.Example 1:Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]Example 2:Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]My Answer  2개의 index 포인터를 이용해서 스왑한다.  l_idx 가 r_idx보다 작을때만 순회한다. 만약 l_idx가 r_idx와 같거나 커지는 경우는 더이상 스왑할 것이 없다는 의미.class Solution {    public void reverseString(char[] s) {        int l_idx = 0;        int r_idx = s.length - 1;                while( l_idx &lt; r_idx ) {            char src = s[l_idx];            char dst = s[r_idx];            s[l_idx++] = dst;            s[r_idx--] = src;           }    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/reverse_string_iteratively.html"
      }        
      ,
    
      "leetcode-2020-02-03-reverse-linked-list-recursively-html": {
        "title": "Reverse Linked List Recursively",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemReverse a singly linked list recursively.Example :Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULLMy Answer  head.next == null 인 경우가 마지막 노드인데, 우린 마지막 노드를 Head로 사용 해야 한다.  이하 head로 되어 있지만, 그냥 cur(현재 처리 중인 노드)로 생각하는게, 이해하는데 도움 된다.  cur.next는 현재 노드의 그 다음 노드를 가리키는데, 이것이 현재 노드의 새로운 head로서 역할해야 한다.  rest는 사실상 맨 마지막 노드만 설정되고 계속 그 상태로 reverseList의 상위 호출 부분으로 가도 무방하다. 어짜피 참조타입이라 reverseList 함수를 재귀로 호출 하는 부분 위, 아래에서 열심히 새로운 형태로 뒤집고 있다. 결국 뒤집어진 완성형을 최종 리턴하기 위한 존재일 뿐.class Solution {    public ListNode reverseList(ListNode head) {        if ( head == null )            return null;                if ( head.next == null)            return head;                ListNode new_head = head.next;                ListNode rest = reverseList(head.next);        head.next = null;        new_head.next = head;               return rest;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/reverse_linked_list_recursively.html"
      }        
      ,
    
      "leetcode-2020-02-03-reverse-linked-list-iteratively-html": {
        "title": "Reverse Linked List Iteratively",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemReverse a singly linked list iteratively.Example :Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULLMy Answer  cur 가 null이 아닐때 까지 순회돌자.  prev에 cur을 할당하기 전까진 이전 노드를 가리키기 때문에, cur.next = prev를 하게 되면 현재 노드의 이전 노드를 다음 노드로 할당한다.  마지막 노드 까지 간 이후 while문을 나오게되면 현재 prev가 가리키고 있는건 마지막 노드이자 Head를 의미 한다./** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {                ListNode cur = head;        ListNode prev = null;                while(cur != null ) {            ListNode next = cur.next;            cur.next = prev;            prev = cur;               cur = next;        }                return prev;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/reverse_linked_list_iteratively.html"
      }        
      ,
    
      "leetcode-2020-02-03-reverse-bits-html": {
        "title": "Reverse Bits",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemReverse bits of a given 32 bits unsigned integer.Note:  Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.  In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.Example 1:Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Example 2:Input: 11111111111111111111111111111101Output: 10111111111111111111111111111111Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.My Answer  32bit 이기 때문에 32번 순회돌자.  순회 돌면서 n의 첫번째 비트의 값을 가져오자 (1 or 0 ) 그러고 나서 n을 오른쪽 시프트해서 그 다음 비트를 첫번째 비트로 변경해 주자.  순회 돌면서 res를 왼쪽 시프트해서 첫번째 비트에 값을 넣을 준비하자.  n의 첫번째 비트의 값을 res에 OR 연산해서 넣어 주자public class Solution {    // you need treat n as an unsigned value    public int reverseBits(int n) {        int res = 0;                for(int i=0;i&lt;32;i++) {                        int x = n &amp; 1;                        n = n &gt;&gt; 1;            res = res &lt;&lt; 1;            res |= x;        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/reverse_bits.html"
      }        
      ,
    
      "leetcode-2020-02-03-replace-words-html": {
        "title": "Replace Words",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemIn English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.You need to output the sentence after the replacement.Example :Input: dict = [\"cat\", \"bat\", \"rat\"]sentence = \"the cattle was rattled by the battery\"Output: \"the cat was rat by the bat\"Note :  The input will only have lower-case letters.  1 &lt;= dict words number &lt;= 1000  1 &lt;= sentence words number &lt;= 1000  1 &lt;= root length &lt;= 100  1 &lt;= sentence words length &lt;= 1000My Answer  dict를 이용해서, Trie를 구성하자.  sentence를 단어 기준으로 분리하고, 각 단어에 대해서 Trie에서 prefix를 찾자.  만약 prefix를 찾았다면, 해당 단어를 반환, 못 찾았다면 원래 단어를 반환  반환된 단어들을 이용해서 하나의 문장을 구성하자.class Solution {    class Trie {        public boolean isWord;        public Trie[] children;        public Trie(){            children = new Trie[26];        }                    public void insert(String word) {            Trie cur = this;                        for(char c : word.toCharArray()) {                if ( cur.children[c-'a'] == null ) {                    cur.children[c-'a'] = new Trie();                }                                cur = cur.children[c-'a'];            }                        cur.isWord = true;        }                public String replace(String word) {                        Trie cur = this;            int i=0;            for(char c : word.toCharArray()){                if ( cur.children[c-'a'] == null ) {                    return word;                }                                cur = cur.children[c-'a'];                i++;                if ( cur.isWord )                    break;            }            //check exist            //not = return word            //ok = rebuild word            return word.substring(0, i);        }    }        public String replaceWords(List&lt;String&gt; dict, String sentence) {        Trie trie = new Trie();                for( String word : dict) {            trie.insert(word);        }                String[] words = sentence.split(\" \");                StringBuilder builder = new StringBuilder();        for(int i=0;i&lt;words.length;i++) {            String word = words[i];            word = trie.replace(word);                            builder.append(word);                        if ( i != words.length-1) {                builder.append(\" \");            }        }                return builder.toString();            }}Fastest Answer  String::split 과 StringBuilder를 사용해서 재 조합하는 대신 String::substring을 이용하도록 변경  start, end를 이용, 각각 sentence에서 단어의 시작 index와 끝 + 1 index를 의미  Trie::replace를 Trie::getPrefixLength 로 변경하고, 기능을 특정 단어에 대해서 변경해야 할 단어가 있는지 확인후 변경할 것이 있다면, 변경해야 하는 단어의 길이를 반환.  만약 Trie::getPrefixLength의 반환 값이 0보다 크다면, 기존 단어에서 필요 없는 부분을 잘라내야 한다. 그래서 0 ~ start + len 부분과 end ~ 부분을 합쳐서 새로운 sentence를 만든다.class Solution {    class Trie {        public boolean isWord;        public Trie[] children;                public Trie() {            children = new Trie[26];        }                    public void insert(String word) {            Trie cur = this;                        for(char c : word.toCharArray()) {                if ( cur.children[c-'a'] == null ) {                    cur.children[c-'a'] = new Trie();                }                cur = cur.children[c-'a'];            }                                            cur.isWord = true;        }                public int getPrefixLength(String sentence, int start, int end ) {            String word = sentence.substring(start,end);                        Trie cur = this;                        int len = 0;                        for(char c : word.toCharArray()) {                if ( cur.children[c-'a'] == null ) {                    return -1;                }                                len++;                cur = cur.children[c-'a'];                if ( cur.isWord )                    break;            }                                            return len;                    }    }        public String replaceWords(List&lt;String&gt; dict, String sentence) {        Trie trie = new Trie();        for(String word : dict ) {            trie.insert(word);        }        int start = 0;        int end = 0;                    while(start &lt; sentence.length() ) {            end = sentence.indexOf(' ', start);            if ( end == -1 ) {                end = sentence.length();            }                        int len = trie.getPrefixLength(sentence, start, end );                        if ( len &gt; 0 ) {                sentence = sentence.substring(0, start + len) + sentence.substring(end);                start = start + len + 1;            } else {                start = end + 1;                }        }                return sentence;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/replace_words.html"
      }        
      ,
    
      "leetcode-2020-02-03-pow-html": {
        "title": "Pow(x,n)",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemImplement pow(x, n), which calculates x raised to the power n (xn).Example 1:Input: 2.00000, 10Output: 1024.00000Example 2:Input: 2.10000, 3Output: 9.26100Example 3:Input: 2.00000, -2Output: 0.25000Explanation: 1/4 = 0.25My Answerclass Solution {    public double myPow(double x, int n) {        if ( n == 0 || x == 1 )            return 1;                if ( x == -1 ) {            boolean b_is_even = n % 2 == 0;            return b_is_even ? 1 : -1;        }                if ( x == 0 || n == Integer.MAX_VALUE || n == Integer.MIN_VALUE)            return 0;                return tailPow(x, 1, n);    }        public double tailPow(double x, double total, int n) {        if ( n == 0 )            return total;                boolean b_is_negative = n &lt; 0;                if ( b_is_negative ) {            return tailPow(x, total/x, ++n);        } else {            return tailPow(x, x * total, --n);            }            }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/pow.html"
      }        
      ,
    
      "leetcode-2020-02-03-populating-next-right-pointers-in-each-node-html": {
        "title": "Populating Next Right Pointers in Each Node",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:struct Node {  int val;  Node *left;  Node *right;  Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL.Example :Figure AFigure B◊Input: root = [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. My Answer  반복문을 이용해서 해결  Depth 별로 첫번째 노드 의 다음 노드는 두번째 이고, 두번째의 다음 노드는 세번째… 마지막 노드의 다음 노드는 null이다.  Queue의 사이즈만큼 반복문을 수행하고, 반복을 수행 할 때 마다, curr을 변경하고, curr.next를 현재 노드로 할당하자.  마지막번째 노드에서는 할당 하지 말고 curr에 null을 할당 하면 된다.  위 예제는 다음과 같은 흐름이 된다.      q = [1],   for {      i : 0          node = 1          curr = null          q.add(2), q.add(3)  }  q = [2,3],  for {      i : 0          node = 2          curr = null          q.add(4), q.add(5)      i : 1          node = 3          curr = 2              curr.next = 3 = 2 -&gt; 3          q.add(5), q.add(7)  }  q = [4,5,6,7],  for {      i : 0          node = 4          curr = null      i : 1          node = 5          curr = 4              curr.next = 5 = 4 -&gt; 5      i : 2          node = 6          curr = 5              curr.next = 6 = 5 -&gt; 6      i : 3          node = 7          curr = 6              curr.next = 7 = 6 -&gt; 7          }      /*// Definition for a Node.class Node {    public int val;    public Node left;    public Node right;    public Node next;    public Node() {}        public Node(int _val) {        val = _val;    }    public Node(int _val, Node _left, Node _right, Node _next) {        val = _val;        left = _left;        right = _right;        next = _next;    }};*/class Solution {    public Node connect(Node root) {        if ( root == null )            return null;                Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();        q.add(root);                Node curr = null;                while(!q.isEmpty()) {                        int n = q.size();                        for(int i=0;i&lt;n;i++) {                Node node = q.poll();                                if ( curr != null ) {                                    curr.next = node;                }                                 if ( i &lt; n - 1 ) {                    curr = node;                } else {                    curr = null;                }                                if ( node.left != null )                    q.add(node.left);                if ( node.right != null )                    q.add(node.right);            }        }                return root;            }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/populating_next_right_pointers_in_each_node.html"
      }        
      ,
    
      "leetcode-2020-02-03-permutations-html": {
        "title": "Permutations",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a collection of distinct integers, return all possible permutations.Example :Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]My Answer  재귀를 이용해서 해결  helper 함수에의 for구문에서 helper 함수를 재귀 호출 한다.  helper 재귀 호출 하기 전과 후에, swap을 통해 배열의 순서를 변경해 주자.class Solution {    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        helper(0, nums, result);        return result;    }     void helper(int start, int[] nums, List&lt;List&lt;Integer&gt;&gt; result){        if(start==nums.length-1){            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();            for(int num: nums){                list.add(num);            }            result.add(list);            return;        }         for(int i=start; i&lt;nums.length; i++){            swap(nums, i, start);            helper(start+1, nums, result);            swap(nums, i, start);        }    }     void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/permutations.html"
      }        
      ,
    
      "leetcode-2020-02-03-path-sum-html": {
        "title": "Path Sum",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.Note:A leaf is a node with no children.Example :Input: [5,4,8,11,null,13,4,7,2,null,null,null,1]22      5     / \\    4   8   /   / \\  11  13  4 /  \\      \\7    2      1Output: trueExplanation: as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.My Answer  재귀를 이용해서 해결  leaf 이면서 최종 sum이 0일때만 true이다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean hasPathSum(TreeNode root, int sum) {        if ( root == null )            return false;                sum -= root.val;                if ( root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0 )            return true;                if ( root.left != null ) {            if ( hasPathSum(root.left, sum) )                return true;        }                if ( root.right != null ) {            if ( hasPathSum(root.right, sum))                return true;        }                return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/path_sum.html"
      }        
      ,
    
      "leetcode-2020-02-03-pascals-triangle-ii-html": {
        "title": "Pascals Triangle II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.Note that the row index starts from 0.Example :Input: 3Output: [1,3,3,1]My Answer  rowIndex의 이전 row의 리스트를 구하고, 그 리스트를 기반으로 새로운 row를 만든다.class Solution {    public List&lt;Integer&gt; getRow(int rowIndex) {        if(rowIndex == 0){            return Arrays.asList(1);        }        List&lt;Integer&gt; list = getRow(rowIndex - 1);        List&lt;Integer&gt; result = new ArrayList();        result.add(1);        for(int i = 1; i &lt; list.size(); i++){            result.add(list.get(i-1)+list.get(i));        }        result.add(1);        return result;    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/pascals_triangle_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-pascals-triangle-html": {
        "title": "Pascal's Triangle",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a non-negative integer numRows, generate the first numRows of Pascal’s triangle.Example :Input: 5Output:[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]My Answer  level이 1일땐 원소가 1 하나 밖에 없는 리스트 이다.  level이 2이상일땐 리스트의 앞, 뒤로 1을 넣어 주고 그 사이를 level-1 만큼 돌면서 이전에 추가된 리스트 ( 이번 level의 값)을 참조해서 원소를 추가 한다.class Solution {   public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        if (numRows == 0) {            return res;        }        res.add(Arrays.asList(1));        for (int level = 2; level &lt;= numRows; ++level) {            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            row.add(1);            List&lt;Integer&gt; prevRow = res.get(level-2);            for (int i = 1; i &lt; level-1; ++i) {                row.add(prevRow.get(i-1)+prevRow.get(i));            }            row.add(1);            res.add(row);        }        return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/pascals_triangle.html"
      }        
      ,
    
      "leetcode-2020-02-03-palindrome-pairs-html": {
        "title": "Palindrome Pairs",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.Example 1:Input: [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]Example 2:Input: [\"bat\",\"tab\",\"cat\"]Output: [[0,1],[1,0]] Explanation: The palindromes are [\"battab\",\"tabbat\"]My Answer  Palindrome은 가운데 기준으로 좌,우에 배치된 문자가 동일한것을 의미 한다.  Trie에는 words의 역순에 해당하는 문자열을 이용해서 구성한다.          예를 들어 words=[\"abc\",\"def\"] 라면 \"cba\", \"fed\"를 활용      위와 같이 역순으로 넣음으로써, Palindrome을 찾기 수월해 진다.      각 마지막 Trie노드에는 원래 단어의 index      각 노드의 이하 Trie노드가 Palindrome일때 원래 단어의 index리스트를 저장하기 위한 p_index. 다음과 같은 흐름이 된다.        words=[\"abc\", \"bcba\", \"sscba\"]trie=c-&gt;b[0]-&gt;a(0), a-&gt;b-&gt;c[1,2]-&gt;b(1)                                -&gt;s[2]-&gt;s(2)                                                                words[0]=\"abc\"의 Palindrome을 찾을때 :trie-&gt;a-&gt;b-&gt;c 노드 까지 찾을 수 있고,c노드의 p_index=[1,2] 이기 때문에, words[1], words[2]와 Palindrome을 구성 한 다는것을 알 수 있다.words[0] + words[1] = \"abcbcba\"words[0] + words[1] = \"abcsscba\"                    class Solution {    class Trie {        public int index;               //현재 단어가 갖고 있던 index        public List&lt;Integer&gt; p_index;   //현재 캐릭터 이하의 경로가 Palindrome일 때, index        public Trie[] children;                public Trie () {            index = -1;        }    }        public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();                   Trie trie = buildTrie(words);                int i=0;        for(String word : words ) {            findPalindrome(trie, word, i++, result);        }                return result;    }    void findPalindrome ( Trie trie, String word, int index, List&lt;List&lt;Integer&gt;&gt; result ) {        int i=0;        int count = word.length();        while(i &lt; count) {      //Trie에 역순으로 들어가 있기 때문에, 정상적으로 앞에서 부터 비교해 나가면 된다.                        if ( trie.children == null ) break;                        char c = word.charAt(i);                        if ( trie.children[c-'a'] == null ) break;                                        if ( trie.index &gt;= 0 &amp;&amp; trie.index != index &amp;&amp; isPalindrome(word, i,count-1) ) {    //word 보다 작은길이가 trie에 이미 있으면서, word의 나머지가 Palindrome이다.                result.add(Arrays.asList(index, trie.index));                }                    trie = trie.children[c-'a'];            i++;        }                if ( !isPalindrome(word, i,count-1) )            return;                if ( trie.index &gt;= 0 &amp;&amp;  trie.index != index ) {            result.add(Arrays.asList(index, trie.index));        }                 if ( i == count &amp;&amp; trie.p_index != null ) {            for(int p_index : trie.p_index ) {                result.add(Arrays.asList(index, p_index));                }                    }    }        Trie buildTrie( String[] words ) {        Trie root = new Trie();                int i=0;        for(String word : words ) {            insert(root, word, i++);        }                return root;    }        void insert( Trie root, String word, int index ) {        int count = word.length();        for(int i=count-1;i&gt;=0;i--) {   //word의 역순으로 Trie를 구성하자.            if ( root.children == null )                 root.children = new Trie[26];                        char c = word.charAt(i);                        if ( root.children[c-'a'] == null )                 root.children[c-'a'] = new Trie();                        if ( isPalindrome(word, 0, i) ) {       //이하 단어 만으로 Palindrome을 만족하는지 확인하자. 만족한다면, 현재 노드까지만 일치 하더라도, 이하는 확인할 필요 없이 만족 한다는것을 증명할 수 있다.                if ( root.p_index == null )                    root.p_index = new ArrayList&lt;&gt;();                root.p_index.add(index);            }                        root = root.children[c-'a'];        }        root.index = index;    }        boolean isPalindrome(String word, int start, int end ) {        while( start &lt; end ) {            if ( word.charAt(start) != word.charAt(end) ) return false;                            start++;            end--;        }                return true;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/palindrome_pairs.html"
      }        
      ,
    
      "leetcode-2020-02-03-n-queens-ii-html": {
        "title": "N-Queens II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.Given an integer n, return the number of distinct solutions to the n-queens puzzle.Example :Input: 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.[ [\".Q..\",  // Solution 1  \"...Q\",  \"Q...\",  \"..Q.\"], [\"..Q.\",  // Solution 2  \"Q...\",  \"...Q\",  \".Q..\"]]My Answer  재귀를 이용해서 해결  board 배열의 index는 Row를 의미하고, 해당 index의 값은 Column을 의미 한다. 예를 들어 zero base, board[1]의 값이 2 라면, 1번 줄의 2번 칸에 퀸이 위치해 있다는 의미.  각 Column 별로 퀸을 위치 시킬수 있는지 isValid 함수로 확인  isValid 함수에서는 현재 Row이전 board 값을 이용해서 위치 시킬수 있는지 확인class Solution {    int cnt = 0;    //NQueens를 위치 시킬수 있는 방법의 총 갯수를 의미        public int totalNQueens(int n) {                placeQueen(new int[n], 0, n);        return cnt;    }    void placeQueen(int[] board, int row, int n_queens) {        if (row == n_queens) {      //현재 Row와 n_queens가 같다는 의미는 모든 Row에 대해서 위치 시켰다는 의미이기 때문에, 횟수 증가            cnt++;            return;        }        for (int i = 0; i &lt; n_queens; i++) {            board[row] = i;            if (isValid(board, row)) {                placeQueen(board, row + 1, n_queens);            }        }    }    boolean isValid(int[] board, int row) {        for (int i = 0; i &lt; row; i++) {     //현재 위치 시키려는 Row이전 board값들을 이용해서 확인            /*            1. board[i] == board[row] 는 현재 위치 시키려는 Row의 값을 이미 이전 Row에서 사용하고 있다. 즉 같은 Column에 배치 하려고 한다.            2. row - i == Math.abs(board[i] - board[row]) 는 현재 위치 시키려는 Column과 대각선으로 위치 하고 있는 값이 있다.            예를 들어 0번째 Row의 3번째 Column에 이미 퀸이 위치해 있고, 1번째 Row의 2번째 Column에 배치 하려고 할때 위 조건을 만족 하게 된다.            [-][-][-][X]            [-][-][X][-]            ....            row(1) - i(0) == Math.abs(board[i](3) - board[row](2))            =&gt; 1 - 0 == Math.abs(3 - 2)            =&gt; 1 == 1 = true            */            if (board[i] == board[row] || row - i == Math.abs(board[i] - board[row])) {                return false;            }        }        return true;    }};",
        "url": "http://localhost:4000//leetcode/2020/02/03/n_queens_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-n-ary-tree-preorder-traversal-html": {
        "title": "N-ary Tree Preorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an n-ary tree, return the preorder traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).Example 1:      1    / | \\   3  2  4  / \\ 5   6Input: root = [1,null,3,2,4,null,5,6]Output: [1,3,5,6,2,4]Example 2:        1     / | | \\    2  3 4  5      /| |  |\\     6 7 8  9 10       | |  |       11 12 13       |      14Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]My Answer ( Recursive )  재귀를 이용  재귀 함수 search에서 Node가 null이 아니라면, 결과 리스트에 Node의 값 부터 넣자.  Node.children을 순회 하면서, search함수를 재귀 호출 하면 된다/*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public List&lt;Integer&gt; preorder(Node root) {                List&lt;Integer&gt; result = new ArrayList&lt;&gt;();                search(root, result);                return result;    }        void search(Node root, List&lt;Integer&gt; result) {        if ( root == null)            return;                result.add(root.val);                for(Node node : root.children ) {            search(node, result);        }    }}My Answer ( Iteration )  반복문 이용  Stack을 이용하자.  순회 돌때 마다 결과 리스트에 curr의 값을 넣자.  만약 curr의 children이 하나라도 있다면, head에 curr을 할당하고, curr에는 head의 첫번째 자식을 할당하자. 그리고 head.children에서 첫번째 자식을 뺀다.  만약 curr이 null이라면, Stack에 있는것들중 children이 있는것을 찾고 해당 Node의 children의 첫번째 자식을 curr에 할당 한다/*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public List&lt;Integer&gt; preorder(Node root) {               List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        Stack&lt;Node&gt; q = new Stack&lt;&gt;();        Node curr = root;                while(curr != null) {            result.add(curr.val);            q.push(curr);                        if ( curr.children.size() &gt; 0 ) {                Node head = curr;                curr = curr.children.get(0);                head.children.remove(0);                         } else {                curr = null;            }                        if ( curr == null ) {                while(!q.isEmpty()) {                    Node candidate = q.peek();                    if ( candidate.children.size() &gt; 0 ) {                        curr = candidate.children.get(0);                        candidate.children.remove(0);                                     if ( candidate.children.size() == 0 )                            q.pop();                        break;                    } else {                        curr = null;                        q.pop();                    }                }                                }        }                return result;    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/n_ary_tree_preorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-n-ary-tree-postorder-traversal-html": {
        "title": "N-ary Tree Postorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an n-ary tree, return the postorder traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).Example 1:      1    / | \\   3  2  4  / \\ 5   6Input: root = [1,null,3,2,4,null,5,6]Output: [5,6,3,2,4,1]Example 2:        1     / | | \\    2  3 4  5      /| |  |\\     6 7 8  9 10       | |  |       11 12 13       |      14Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]My Answer ( Recursive )  재귀를 이용  재귀 함수 search에서 Node가 null이 아니라면, Node.children을 순회 하면서, search함수를 재귀 호출하자.  결과 리스트에 Node의 값을 넣자/*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public List&lt;Integer&gt; postorder(Node root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();                search(root, result);                return result;    }        void search(Node root, List&lt;Integer&gt; result) {        if ( root == null )            return;                for(Node node : root.children ) {            search(node, result);        }                result.add(root.val);    }}My Answer ( Iteration )  반복문 이용  Stack을 이용하자.  만약 curr이 null이라면, Stack에서 children이 있는것들중 해당 Node의 마지막 자식을 curr에 할당하자.  만약 curr이 null이 아니라면, 결과 리스트의 첫번째에 curr의 값을 넣고, children의 마지막 자식을 curr에 할당하자. 만약 자식이 없다면 curr을 null로 할당하자./*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public List&lt;Integer&gt; postorder(Node root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();                Stack&lt;Node&gt; s = new Stack&lt;&gt;();        Node curr = root;                while( !s.isEmpty() || curr != null ) {            if ( curr != null ) {                s.push(curr);                result.add(0, curr.val);                                if ( curr.children.size() &gt; 0 ) {                    Node head = curr;                                    curr = head.children.get(head.children.size() -1);                    head.children.remove(head.children.size() - 1);                } else {                    curr = null;                }            } else {                curr = s.peek();                                if ( curr.children.size() &gt; 0 ) {                    Node head = curr;                                    curr = head.children.get(head.children.size() -1);                    head.children.remove(head.children.size() - 1);                    if ( head.children.size() == 0 )                        s.pop();                } else {                    curr = null;                    s.pop();                }            }                    }        return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/n_ary_tree_postorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-n-ary-tree-levelorder-traversal-html": {
        "title": "N-arty Tree Level Order Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an n-ary tree, return the level order traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).Example 1:      1    / | \\   3  2  4  / \\ 5   6Input: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]Example 2:        1     / | | \\    2  3 4  5      /| |  |\\     6 7 8  9 10       | |  |       11 12 13       |      14Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]My Answer  반복문 이용  Queue에는 기존 Queue에 있던것 만큼 순회돌면서, 결과 리스트에 넣고 children을 Queue에 넣는다./*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if ( root == null )            return result;                Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();        q.add(root);                while(!q.isEmpty()) {            List&lt;Integer&gt; sub_result = new ArrayList&lt;&gt;();                        int n = q.size();                        for(int x=0;x&lt;n;x++) {                Node node = q.poll();                    sub_result.add(node.val);                                for(Node child : node.children ) {                    q.add(child);                }            }                        result.add(sub_result);        }                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/n_ary_tree_levelorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-min-idx-sum-two-lists-html": {
        "title": "Minimum Index Sum of Two Lists",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemSuppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.Example 1:Input:[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"][\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]Output: [\"Shogun\"]Explanation: The only restaurant they both like is \"Shogun\".Example 2:Input:[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"][\"KFC\", \"Shogun\", \"Burger King\"]Output: [\"Shogun\"]Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).Note :  The length of both lists will be in the rang of [1,1000].  The length of strings in both lists will be in the range of [1,30].  The index is starting from 0 to the list length minus 1.  No duplicates in both listsMy Answer  HashMap을 이용하자. list1을 순회하면서 HashMap의 키로 list1[i]를 넣고 값으로 index(i)를 넣자.  list2를 순회하면서, HashMap에 list2[i]가 키로 있는것만 확인하면된다.  HashMap의 값 + i가 Sum이 되고, 최소Sum과 비교 하자.  만약 최소Sum보다 Sum이 작다면, 최소Sum을 만족하는 값의 갯수를 1로 초기화.  만약 최소Sum과 Sum이 같다면, 최소Sum을 만족하는 값의 갯수를 1증가.  위의 2가지 경우에 대해서, list1[최소Sum을 만족하는 값의 갯수-1]에 list2[i]를 할당하자. 차후에 결과 배열로 옮기기 위한 사전단계이다. 위 예제2는 다음과 같은 흐름으로 진행 된다.      list1=[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]  list2=[\"KFC\", \"Shogun\", \"Burger King\"]  1:      curr = list2[0] = KFC      sum = HashMap[KFC] + 0 = 3 + 0 = 3      min_sum &gt; sum          min_sum_count=1, list1[min_sum_count-1] = list1[0] = KFC  2:      curr = list2[1] = Shogun      sum = HashMap[Shogun] + 1 = 0 + 1 = 1      min_sum &gt; sum          min_sum_count=1, list1[min_sum_count-1] = list1[0] = Shogun  3:       curr = list2[2] = Burger King      sum = HashMap[Burger King] + 2 = 2 + 2 = 4      min_sum &lt; sum  result = list1[0~min_sum_count-1] = list1[0] = [Shogun]        list2의 순회가 끝나면, list1[0 ~ 최소Sum을 만족하는 값의 갯수-1]가 정답이다. 따라서 결과배열로 옮겨주자.class Solution {    public String[] findRestaurant(String[] list1, String[] list2) {        Map&lt;String, Integer&gt; hashmap = new HashMap&lt;&gt;();                for(int i=0;i&lt;list1.length;i++) {            hashmap.put(list1[i],i);                    }                int min_sum = Integer.MAX_VALUE;        int duple_count=0;        for(int i=0;i&lt;list2.length;i++) {            if ( !hashmap.containsKey(list2[i])) continue;                        int sum = hashmap.get(list2[i]) + i;                        if ( min_sum &gt;= sum ) {                duple_count = min_sum &gt; sum ? 1 : duple_count+1;                                list1[duple_count-1] = list2[i];            }                                    min_sum = min_sum &lt; sum ? min_sum : sum;        }                  String[] result = new String[duple_count];                System.arraycopy(list1, 0, result, 0, duple_count);                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/min_idx_sum_two_lists.html"
      }        
      ,
    
      "leetcode-2020-02-03-merge-two-sorted-lists-html": {
        "title": "Merge Two Sorted Lists",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4My Answer  재귀로 구현  base case 는 l1, l2 둘다 null일때  l1, l2 둘중에 값이 작은 것을 선택한다.  만약 둘중에 null인 것이 있다면 다른것을 선택하자./** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode head = new ListNode(0);                mergeTwoLists(head, l1, l2);                return head.next;    }        void mergeTwoLists(ListNode result, ListNode l1, ListNode l2) {        if ( l1 == null &amp;&amp; l2 == null )            return;                if ( l1 == null || (l2 != null &amp;&amp; l1.val &gt; l2.val) ) {            result.next = l2;            l2 = l2.next;        } else {            result.next = l1;            l1 = l1.next;        }                mergeTwoLists(result.next, l1, l2);    }}Fastest Answer  반복을 이용해서 구현  l1, l2 둘다 null이 될때까지 수행  비교해서 최종 리스트에 넣는다.class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1 == null) return l2;        if(l2 == null) return l1;                ListNode start;        if (l1.val &lt;=  l2.val){            start = l1;            l1 = l1.next;        } else {            start = l2;            l2 = l2.next;        }        ListNode call = start;                while(l1 != null || l2 != null){            if (l1 == null){                start.next = l2;                l2 = null;                            } else if (l2 == null){                start.next =l1;                l1 = null;                            } else if (l1.val &lt;= l2.val){                start.next = l1;                l1 = l1.next;            } else {                start.next = l2;                l2 = l2.next;            }            start = start.next;                    }        return call;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/merge_two_sorted_lists.html"
      }        
      ,
    
      "leetcode-2020-02-03-merge-sorted-array-html": {
        "title": "Merge Sorted Array",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:  The number of elements initialized in nums1 and nums2 are m and n respectively.  You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.Example:Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3Output: [1,2,2,3,5,6]My Answer  nums2를 순회 하면서 nums1에서 넣을 위치를 찾자.  넣을 위치를 찾았는데, nums1의 실제 요소들의 갯수 ( m + i) 이라면 그냥 넣고 끝          m + i 이라는 의미는 넣을 위치가 현재 요소들 보다 큰 숫자이기 때문에, 맨 뒤에 넣으면 된다는 뜻        위 조건이 아니라면, 실제 요소들의 끝부터 넣을 위치 까지의 값들을 하나씩 뒤로 밀어 주자.그러고 나서, 넣을 위치에 num2를 넣는다.  sorted 이기때문에, 마지막 넣은 위치를 기억해 놓고, 다음에 넣을 위치 찾을땐 마지막 넣은 위치 부터 순회 돌면 된다.class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        int n_checked_idx = 0;      //마지막으로 num2를 삽입한 위치        for(int i = 0; i&lt;n; i++ ) {            int num2 = nums2[i];            for(int j = n_checked_idx; j &lt; m; j++) {                int num1 = nums1[j];                if ( num1 &gt; num2 ) {                    n_checked_idx = j;                    break;                } else if ( j +1 == m ) {                    n_checked_idx = m;                }            }            if ( n_checked_idx &lt; nums1.length ) {                for(int j = m - 1; j &gt;= n_checked_idx; j--) {                    int temp = nums1[j];                    nums1[j] = nums1[j+1];                    nums1[j+1] = temp;                }               }            nums1[n_checked_idx] = num2;            m++;        }            }}Fastest Answer  nums1의 복사본을 하나 만든다 (tmp) 이후 nums1은 결과를 담을 배열로서 활용  tmp와 nums2를 처음 부터 순회하는데, 각각 m과 n보다 작을때 까지 돌면서 작은 값을 nums1의 앞부터 채운다.  그 다음 첫번째 조건에 의해서 m 혹은 n 갯수만큼 못 할경우가 발생하기 때문에, 각각 tmp, nums2의 나머지 부분을 nums1에 채워준다.class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        int tmp[] = new int[m];        System.arraycopy(nums1,0,tmp,0,m);        int p =0,q=0,k=0;        while(p&lt;m &amp;&amp; q &lt;n){            if(tmp[p] &lt;= nums2[q]){                nums1[k++] = tmp[p++];            }else{                 nums1[k++] = nums2[q++];            }        }        //output : [1,2,2,3,0,0]        while(p&lt;m){             nums1[k++] = tmp[p++];        }        //output : [1,2,2,3,0,0]        while(q&lt;n){            nums1[k++] = nums2[q++];        }        //output : [1,2,2,3,5,6]    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/merge_sorted_array.html"
      }        
      ,
    
      "leetcode-2020-02-03-median-of-two-sorted-arrays-html": {
        "title": "Median of Two Sorted Arrays",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemThere are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5What is Median  Median(중앙값)은 하나의 집합을 두개의 각기 다른 집합으로 나누는 특성을 갖는 값이다.  작은 값들로만 이루어진 집합(A)와  큰 값들로만 이루어진 집합(B)로 나눈다.  A집합의 가장 큰값은 B집합의 가장 작은 값보다 작다.  A집합의 갯수와 B집합의 갯수는 동일하다.My Answer  2개의 배열을 하나의 배열로 합치자.  이미 정렬되어 있는 배열들 이기 때문에, 모든 원소  만큼 순회할 필요 없고  만큼만 순회 하자.  반복문에서 nums1과 nums2에 있는 값 중 작은 값을 merge 배열에 넣는다.  이 짝수라면, 가 정답  이 홀수라면, 가 정답class Solution {    public double findMedianSortedArrays(int[] nums1, int[] nums2) {        int m = nums1.length;        int n = nums2.length;        int[] merge = new int[m+n];        int mid = (m+n)/2;                int i=0;        int j=0;        int s=0;                while ( s &lt;= mid ) {                        if ( m == 0 || i &gt;= m ) {                merge[s++] = nums2[j++];            } else if ( n == 0 || j &gt;= n) {                merge[s++] = nums1[i++];            } else if ( nums1[i] &lt; nums2[j] ) {                merge[s++] = nums1[i++];            } else if ( nums1[i] &gt; nums2[j] ) {                merge[s++] = nums2[j++];            } else {                if ( n &gt; m ) {                    merge[s++] = nums2[j++];                } else {                    merge[s++] = nums1[i++];                }            }                    }           if ( (m+n)%2 == 0 ) {            return (merge[mid] + merge[mid-1]) / 2.0;        } else {            return merge[mid];        }            }}Solution  LeetCode의 Solution 내용이다.  median(m)을 찾기 위해,다음의 조건식을 만족한다.                                                                                                                                                      , when  is odd      , when  is even        m이 n보다 작거나 같아야 한다. 가 되면, 5번 수식에 의해서 j가 음수가 나오기 때문이다. 따라서 수식에서 A는 B보다 갯수가 작거나 같다.  중앙값을 기준으로 좌, 우의 집합의 갯수가 같아야 하기 때문에, 이 짝수면 중간값을 산출해야 하고, 홀수면 중간값이 중앙값이다.class Solution {    public double findMedianSortedArrays(int[] nums1, int[] nums2) {        int m = nums1.length;        int n = nums2.length;                if ( m &gt; n ) {            int[] temp = nums1;            nums1 = nums2;            nums2 = temp;            int t = m;            m = n;            n = t;                   }                int l=0;        int r=m;        int half = (m + n + 1)/2;                while( l &lt;= r ) {            int i = (l+r)/2;            int j = half - i;                        if ( i &lt; r &amp;&amp; nums2[j-1] &gt; nums1[i]) {// nums1[i]가 너무 작기 때문에, 다음 값을 찾기 위해서 증가 시켜준다.                l = i + 1;            } else if ( i &gt; l &amp;&amp; nums1[i-1] &gt; nums2[j]) {  //nums1[i-1]이 너무 크기 때문에, 다음 값을 찾기 위해서 감소 시켜준다.                r = i - 1;            } else {    //적절한 i를 찾았다.                int max_left = 0;                if ( i == 0 ) {                    max_left = nums2[j-1];                } else if ( j == 0 ) {                    max_left = nums1[i-1];                } else {                    max_left = Math.max(nums1[i-1], nums2[j-1]);                }                                if ( (m+n)%2 == 1) {                    return max_left;                }                                int min_right = 0;                if (i == m) {                    min_right = nums2[j];                } else if (j == n) {                     min_right = nums1[i];                } else {                     min_right = Math.min(nums2[j], nums1[i]);                }                return (max_left + min_right) / 2.0;            }        }                return 0;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/median_of_two_sorted_arrays.html"
      }        
      ,
    
      "leetcode-2020-02-03-maximum-depth-of-n-ary-tree-html": {
        "title": "Maximum Depth of N-ary Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a n-ary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).Example 1:      1    / | \\   3  2  4  / \\ 5   6Input: root = [1,null,3,2,4,null,5,6]Output: 3Example 2:        1     / | | \\    2  3 4  5      /| |  |\\     6 7 8  9 10       | |  |       11 12 13       |      14Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: 5My Answer  재귀를 이용/*// Definition for a Node.class Node {    public int val;    public List&lt;Node&gt; children;    public Node() {}    public Node(int _val) {        val = _val;    }    public Node(int _val, List&lt;Node&gt; _children) {        val = _val;        children = _children;    }};*/class Solution {    public int maxDepth(Node root) {        if ( root == null )            return 0;                int max_depth = 0;        for(Node node : root.children ) {            max_depth = Math.max(max_depth, maxDepth(node));                    }                return max_depth +1;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/maximum_depth_of_n_ary_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-maximum-depth-of-binary-tree-html": {
        "title": "Maximum Depth of Binary Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.A leaf is a node with no children.Note:  Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.  In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.Example :Input:[3,9,20,null,null,15,7],    3   / \\  9  20    /  \\   15   7Output: 3My Answer ( Recursive )  재귀를 이용하는데, TreeNode::left, TreeNode::right가 있으니 각각의 최대 깊이를 구해야 한다.  현재 root가 null이 아니라는것은 기본적으로 1의 값을 가지고 있다는 것이고, 자식 노드(left, right)의 최대 깊이 와 더하면 현재 root의 최대 깊이가 나온다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public int maxDepth(TreeNode root) {        if ( root == null )            return 0;                int n_max_left = 0;        int n_max_right = 0;        int n_max_child = 0;                if ( root.left != null ) {            n_max_left = maxDepth(root.left);        }                if ( root.right != null ) {            n_max_right = maxDepth(root.right);        }                n_max_child = n_max_left &gt; n_max_right ? n_max_left : n_max_right;                return 1 + n_max_child;    }    }My Answer ( Iteration )  반복문 이용  Queue를 이용해서 뎁스 별로 자식 노드를 추가 하는 식으로 구현  q.size() 가 의미 하는것이 현재 뎁스의 노드의 갯수 이다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public int maxDepth(TreeNode root) {        int n_depth = 0;        if ( root == null )            return 0;        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        q.add(root);                while (!q.isEmpty()) {                           int n = q.size();            for(int i = 0;i&lt; n; i++) {                TreeNode node = q.poll();                                    if ( node.left != null )                    q.add(node.left);                if ( node.right != null )                    q.add(node.right);            }            n_depth++;           }                return n_depth;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/maximum_depth_of_binary_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-max-xor-two-numbers-in-array-html": {
        "title": "Maximum XOR of Two Numbers in an Array",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a non-empty array of numbers, Find the maximum result of  XOR , where 0 ≤ i, j &lt; n.Could you do this in O(n) runtime?Example :Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28.My Answer  nums의 숫자들을 bit표현으로 Trie를 구성해 놓는다. int는 32bit 이기 때문에, 32개로 구성.  nums의 숫자들을 순회 하면서, 구성해 놓은 Trie와 반대되는 비트에 해당하는 자식을 다음 Trie노드로 사용한다.          왜냐하면, XOR연산은 bit가 서로 다를때 1이고, 같을때 0이기 때문.        만약 다른 bit에 해당 하는 자식이 있다면, max_xor에 현재 비트 위치에 1을 할당한 값을 더한다.class Trie {    public Trie one;    public Trie zero;        public void insert(int n) {        Trie cur = this;                for(int i=31;i&gt;=0;i--) {            int bit = ( n &gt;&gt; i) &amp; 1;            if ( bit == 0 &amp;&amp; cur.zero == null ) {                cur.zero = new Trie();            } else if ( bit == 1 &amp;&amp; cur.one == null ) {                cur.one = new Trie();              }                            cur = bit == 1 ? cur.one : cur.zero;        }    }}class Solution {    public int findMaximumXOR(int[] nums) {        Trie trie = new Trie();                for(int n : nums) {            trie.insert(n);        }                int max = Integer.MIN_VALUE;                for(int n : nums) {            Trie cur = trie;            int max_xor = 0;            for(int i=31;i&gt;=0;i--) {                int bit = ( n &gt;&gt; i) &amp; 1;                Trie next = bit == 1 ? cur.zero : cur.one;                if ( next != null ) {                    max_xor += 1 &lt;&lt; i;                    cur = next;                } else {                    cur = bit == 1 ? cur.one : cur.zero;                }                            }            max = max &gt; max_xor ? max : max_xor;        }                return max;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/max_xor_two_numbers_in_array.html"
      }        
      ,
    
      "leetcode-2020-02-03-lowest-common-ancestor-of-a-bst-html": {
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]Example 1:Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6.Example 2:Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.Notes  All of the nodes’ values will be unique  p and q are different and both values will exist in the BST.My Answer  BST의 특징을 이용하자.                                p와 q중에 큰 값(b)와 작은 값(s)가 무엇인지 다음의 조건을 이용해서 확인.          만약  라면 root가 LCA이다.      만약  라면 root.left 를 기준으로 다시 1번 조건을 만족하는지 확인해야 한다.      만약  라면 root.right 를 기준으로 다시 1번 조건을 만족하는지 확인해야 한다.      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        int min = 0;        int max = 0;                if ( p.val &gt; q.val ) {            min = q.val;            max = p.val;        } else {            min = p.val;            max = q.val;        }                if ( min &lt;= root.val &amp;&amp; max &gt;= root.val )   //1번 조건            return root;                if ( min &lt; root.val &amp;&amp; max &lt; root.val ) {   //2번 조건            return lowestCommonAncestor(root.left, p, q);        } else {                                    //3번 조건            return lowestCommonAncestor(root.right, p, q);        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/lowest_common_ancestor_of_a_bst.html"
      }        
      ,
    
      "leetcode-2020-02-03-lowest-common-ancestor-of-a-binarytree-html": {
        "title": "Lowest Common Ancestor of a Binary Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.Notes  All of the nodes’ values will be unique  p and q are different and both values will exist in the binary treeMy Answer  p 와 q에 대해서 각각의 경로를 구한다.  각 경로를 하나씩 비교해 나가면서 값이 달라지는 순간 비교를 끝낸다.  search 함수에서 원하는 값에 대응되는 TreeNode 를 찾을때 까지 재귀호출 하고, 찾게되면 Stack에 하나씩 넣는다.  각 Stack을 순회 하면서, TreeNode의 값이 달라지는 순간 까지 순회 한다.  값이 달라지기 직전의 TreeNode가 LCA이다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        Stack&lt;TreeNode&gt; history_q = new Stack&lt;&gt;();        Stack&lt;TreeNode&gt; history_p = new Stack&lt;&gt;();                search(root, p.val, history_p);        search(root, q.val, history_q);                TreeNode result = root;                while ( !history_p.isEmpty() &amp;&amp; !history_q.isEmpty()) {            TreeNode root_p = history_p.pop();                TreeNode root_q = history_q.pop();                            if ( root_p.val != root_q.val )                break;                        result = root_p;    //둘중에 뭘 넣든 상관없다. 값이 같다는것은 똑같은 객체라는 것이니까.        }                    return result;    }        boolean search(TreeNode root, int val, Stack&lt;TreeNode&gt; history) {        if ( root.val == val ) {            history.push(root);            return true;        }                    if ( root.left != null &amp;&amp; search(root.left, val, history)) {            history.push(root);            return true;        }                if ( root.right != null &amp;&amp; search(root.right, val, history)) {            history.push(root);            return true;        }                return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/lowest_common_ancestor_of_a_binarytree.html"
      }        
      ,
    
      "leetcode-2020-02-03-longest-substring-without-repeating-characters-html": {
        "title": "Longest Substring Without Repeating Characters",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a string, find the length of the longest substring without repeating characters.Example 1:Input: \"abcabcbb\"Output: 3 Explanation: The answer is \"abc\", with the length of 3.Example 2:Input: \"bbbbb\"Output: 1Explanation: The answer is \"b\", with the length of 1.Example 3:Input: \"pwwkew\"Output: 3Explanation: The answer is \"wke\", with the length of 3.              Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.My Answer ( Use HashSet)  HashSet을 이용하자.  s를 순회하면서 HashSet에 포함되어 있는 문자 인지 확인하고, 포함되어 있는 문자라면 HashSet을 초기화 하면서 기존의 max보다 멀리 왔는지 확인.class Solution {    public int lengthOfLongestSubstring(String s) {        Set&lt;Character&gt; hashset = new HashSet&lt;&gt;();        int length = s.length();        int max = 0;        int sub_count = 0;        int i=0;                while ( i &lt; length ) {            char c = s.charAt(i);            if (hashset.contains(c)) {                max = max &gt; sub_count ? max : sub_count;                                  if (i == 0 || c != s.charAt(i-1))                     i=i-sub_count + 1;                                                hashset.clear();                sub_count=0;                                            } else {                hashset.add(c);                            sub_count++;                            i++;            }        }                max = max &gt; sub_count ? max : sub_count;          return max;    }}My Answer  ASCII코드에 해당하는 문자만 들어오기 때문에, 128개의 int배열로 해결 할 수 있다.  알고리즘은 다음과 같다.          문자열 s에 대해서, 특정 문자가 반복되기 전까지의 substring의 길이를 구하고 최대 값을 유지 한다.      시작index ~ 문자 중복 발생 or 문자열의 끝이 최대 값을 비교 할 수 있는 후보이다.      특정 문자에 대해서 중복이 발생했을때 시작index를 변경해 줘야 한다.                  예를들어 s[1,2,3]을 확인중에 s[4]가 s[1]과 중복문자 라면 다음 확인해야 하는 substring은 s[2] 부터 시작하는 문자열 이어야 한다.          예를들어 s[1,2,3]을 확인중에 s[4]가 s[2]와 중복문자 라면 다음 확인해야 하는 substring은 s[3] 부터 시작하는 문자열 이어야 한다.          따라서, 각 문자에 대해서 중복이 발생했을때 변경할 시작index를 저장하자.                      문자 s[i]가 곧 int배열(arr)의 index가 되고, arr의 값은 문자의 문자열 s의 위치 + 1이 된다.  현재 확인중인 substring의 시작 위치를 의미하는 변수 start를 사용.  s를 순회 하면서 다음과 같은 흐름으로 진행한다.          start 갱신 : 기존 start와 arr[s[i]] 중 최대 값.      최대 문자열(max) 갱신 : 기존 최대 문자열과 i-start+1 중 최대 값.      arr[s[i]] 갱신 : i+1        예를 들어 다음과 같은 흐름으로 진행 된다.      Input: abcbdef  1:      c=s[0]='a'      start=0, max=Max(max, i-start+1=1)=1      arr['a']=1  2:      c=s[1]=`b`      start=0, max=Max(max,i-start+1=2)=2      arr['b']=2  3:      c=s[2]='c'      start=0, max=Max(max,i-start+1=3)=3      arr['b']=3  4:      c=s[3]='b'        start=Max(start, arr['b']=2)=2      //중복 발생이기때문에 arr['b']의 값으로 start가 변경된다. 즉 기존엔 a,b,c가 확인해야할 substring 이였다면 지금부턴 c부터가 확인해야할 substring이 된다.      max=Max(max,i-start+1=3-2+1)=3            arr['b']=4  5:      c=s[4]='d'      start=2, max=Max(max,i-start+1=4-2+1)=3      arr['d']=5  ...      class Solution {    public int lengthOfLongestSubstring(String s) {        int[] arr = new int[128];        int length = s.length();        int max = 0;        int start=0;        for(int i=0;i&lt;length;i++) {                        start = Math.max(start, arr[s.charAt(i)]);            max = Math.max(max,i-start+1);                        arr[s.charAt(i)]=i+1;                        }        return max;    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/longest_substring_without_repeating_characters.html"
      }        
      ,
    
      "leetcode-2020-02-03-longest-palindromic-substring-html": {
        "title": "Longest Palindromic Substring",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.Example 1:Input: \"babad\"Output: \"bab\"Note: \"aba\" is also a valid answer.Example 2:Input: \"cbbd\"Output: \"bb\"My Answer  문자열을 순회 하면서, 각 index를 중심으로 좌, 우로 비교해 나가면서 동일한 값의 길이를 구한다.class Solution {    public String longestPalindrome(String s) {        if (s == null || s.length() &lt; 1) return \"\";        int start = 0, end = 0;        for (int i = 0; i &lt; s.length(); i++) {            int len1 = expandAroundCenter(s, i, i);            int len2 = expandAroundCenter(s, i, i + 1);            int len = Math.max(len1, len2);            if (len &gt; end - start) {                start = i - (len - 1) / 2;                end = i + len / 2;            }        }        return s.substring(start, end + 1);    }    private int expandAroundCenter(String s, int left, int right) {        int L = left, R = right;        while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) {            L--;            R++;        }        return R - L - 1;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/longest_palindromic_substring.html"
      }        
      ,
    
      "leetcode-2020-02-03-letter-combination-phone-html": {
        "title": "Letter Combinations of a Phone Number",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Example :Input: \"23\"Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].My Answer  재귀로 해결  사전에 HashMap을 이용해서 각 숫자별 매칭될 문자열을 지정해 주자.  digits에 HashMap에 지정되지 않은 숫자가 넘어 올 수 있기 때문에, 이런 경우 빈 결과를 리턴  StringBuilder를 이용해서 중간 과정들을 저장하고, digits의 숫자 갯수와 동일해 지면 StringBuilder의 문자열을 결과 리스트에 넣는다.class Solution {        Map&lt;Character, String&gt; map_digits = new HashMap&lt;Character, String&gt;(){{        put('2', \"abc\");        put('3', \"def\");        put('4', \"ghi\");        put('5', \"jkl\");        put('6', \"mno\");        put('7', \"pqrs\");        put('8', \"tuv\");        put('9', \"wxyz\");    }};        public List&lt;String&gt; letterCombinations(String digits) {                List&lt;String&gt; result = new ArrayList&lt;&gt;();        if ( digits.isEmpty() )             return result;                char[] input = digits.toCharArray();                for(char c : input) {            if ( !map_digits.containsKey(c) ) {                return result;            }        }                StringBuilder str = new StringBuilder();                backTracking(input, result, str, 0);                return result;    }        void backTracking(char[] input, List&lt;String&gt; result, StringBuilder str, int start) {        if ( start == input.length ) {            result.add(str.toString());            return;        }                String alpha = map_digits.get(input[start]);                char[] arr_alpha = alpha.toCharArray();                for(int i = 0; i &lt; arr_alpha.length; i++) {            str.append(arr_alpha[i]);            backTracking(input, result, str, start +1);            str.deleteCharAt(str.length() - 1);        }       }    }Simple Answer  재귀를 이용해서 해결, StringBuilder나 사전에 digits 검사 없이 진행class Solution {    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    List&lt;String&gt; output = new ArrayList&lt;&gt;();    public List&lt;String&gt; letterCombinations(String digits) {        if(digits.length() == 0 || digits == null) {            return output;        }        map.put(\"2\",\"abc\");        map.put(\"3\",\"def\");        map.put(\"4\",\"ghi\");        map.put(\"5\",\"jkl\");        map.put(\"6\",\"mno\");        map.put(\"7\",\"pqrs\");        map.put(\"8\",\"tuv\");        map.put(\"9\",\"wxyz\");                helper(\"\", digits);        return output;    }        private void helper(String combination, String nextDigits) {        if(nextDigits.length() == 0) {            output.add(combination);            return;        }                String digit = String.valueOf(nextDigits.charAt(0));        String letters = map.get(digit);        for(int i = 0; i &lt; letters.length(); i++) {            String letter = String.valueOf(letters.charAt(i));            helper(combination + letter, nextDigits.substring(1));        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/letter_combination_phone.html"
      }        
      ,
    
      "leetcode-2020-02-03-largest-rectangle-in-histogram-html": {
        "title": "Largest Rectangle in Histogram",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].The largest rectangle is shown in the shaded area, which has area = 10 unit.Example :Input: [2,1,5,6,2,3]Output: 10My Answer  재귀를 이용해서 해결  backTracking 함수의 파라미터로 기준이 되는 index 를 넘긴다.  backTracking 함수에서는 start index에 해당 하는 pivot을 기준으로 좌,우의 값을 비교 해서 같거나 클때 count를 증가 시킨다.  while(prev &gt;= 0 || next &lt; length ) { 구문 이후 최종 계산된 count와 pivot의 곱을 통해 현재 기준값으로 나올수 있는 최대 값을 구하고,  재귀를 통해 그 다음 index에 해당 하는 값을 구해서 Max 비교 한다.  모든 원소에 대해서 수행하기 때문에, 연산량이 많다.class Solution {    public int largestRectangleArea(int[] heights) {        return backTracking(heights, 0);    }        int backTracking(int[] heights, int start ){        if ( heights.length &lt;= start) {            return 0;        }                int pivot = heights[start];        int count = 1;        int prev = start -1;        int next = start + 1;        int length = heights.length;                while(prev &gt;= 0 || next &lt; length ) {            if ( prev &gt;= 0 ) {                if ( heights[prev] &gt;= pivot ) {                    count++;                    prev--;                 } else {                    prev = -1;                }                            }                        if ( next &lt; length ) {                if( heights[next] &gt;= pivot ) {                    count++;                    next++;                } else {                    next = length;                }            }                    }               int total = pivot * count;        int next_total = backTracking(heights, start +1);                return Math.max(total, next_total);            }}Fastest Answerclass Solution {    public int largestRectangleArea(int[] heights) {        if (heights == null || heights.length == 0) {            return 0;        }        return lra(heights, 0, heights.length);    }    private int lra(int[] heights, int start, int end) {        if (end - start == 1) {            return heights[start];        }        //start index에 해당 하는 값을 기준으로 최소 값을 구한다.        //start ~ end 사이 값들을 비교하면서, 요소들이 오름차순으로만 구성되어 있는지, 내림차순으로만 구성 되어 있는지, 아니면 뒤죽박죽 섞여 있는지 체크한다.        boolean ascd = true;        boolean desc = true;        int min = heights[start];        for (int i = start + 1; i &lt; end; i++) {            if (heights[i] &lt; min) {                min = heights[i];            }            if (heights[i] &lt; heights[i-1]) {                ascd = false;            } else if (heights[i] &gt; heights[i-1]) {                desc = false;            }        }        int max = min * (end - start);  //위 반복문에 의해서 결정된 min값과 end-start의 곱이 곧 start 기준에 나올수 있는 최대 값이다.                if (ascd) { //오름 차순으로되어 있다면, start + 1 ~ end 까지 최대 값을 구해서 비교            for (int i = start + 1; i &lt; end; i++) {                if (heights[i] == heights[i-1]) continue;                int tmp = heights[i] * (end - i);                if (tmp &gt; max) {                    max = tmp;                }            }        } else if (desc) { //내림 차순으로되어 있다면, 뒤쪽부터 작은 수 이기 때문에, end-2 ~ start 까지 최대 값을 구해서 비교            for (int i = end - 2; i &gt;= start; i--) {                if (heights[i] == heights[i+1]) continue;                int tmp = heights[i] * (i - start + 1);                if (tmp &gt; max) {                    max = tmp;                }            }        } else {            boolean getStart = false;            for (int i = start; i &lt; end; i++) {                if (!getStart) {                    if (heights[i] == min) continue;                    start = i;                    getStart = true;                } else {                    if (heights[i] != min) continue;                    int tmp = lra(heights, start, i);                    if (tmp &gt; max) {                        max = tmp;                    }                    getStart = false;                }            }            if (getStart) {                int tmp = lra(heights, start, end);                if (tmp &gt; max) {                    max = tmp;                }            }        }        return max;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/largest_rectangle_in_histogram.html"
      }        
      ,
    
      "leetcode-2020-02-03-kth-symbol-in-grammar-html": {
        "title": "K-th Symbol in Grammar",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemOn the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).Example :Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001My Answer  이진 트리로 생각 할 수 있다.  부모노드가 0일때 왼쪽 자식 노드는 0, 오른쪽 자식 노드는 1  부모노드가 1일때 왼쪽 자식 노드는 1, 오른쪽 자식 노드는 0    만약 K가 짝수이면 k/2번째 노드의 오른쪽 노드이다.  만약 K가 홀수이면 (k+1)/2 번째 노드의 왼쪽 노드이다.  하지만, 부모노드의 값을 알아야 하기 때문에, 재귀로 부모 노드의 값이 뭔지 알아 낸다.class Solution {    public int kthGrammar(int N, int K) {        if ( N == 1 ) {     //N이 1이라는것은 루트노드 (0)을 의미 K는 의미 없다.            return 0;          } else if ( K % 2 == 0 ) {  // K가 짝수라면, 이전 Row의 K/2의 값이 뭔지 알아내야 한다. 그것이 부모노드니까. 그리고, 부모노드가 0이라면 나는 1이고 1이라면 나는 0이다.            return kthGrammar ( N -1, K / 2) == 0 ? 1 : 0;        } else {      // K가 홀수라면, 이전 Row의 (K+1)/2의 값이 뭔지 알아내야 한다. 그것이 부모노드니까. 그리고, 부모노드가 0이라면 나는 0이고 1이라면 나는 1이다.            return kthGrammar( N -1, (K + 1) /2) == 0 ? 0 : 1;               }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/kth_symbol_in_grammar.html"
      }        
      ,
    
      "leetcode-2020-02-03-kth-largest-element-stream-html": {
        "title": "Kth Largest Element in a Stream",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemDesign a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.Example :int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3);   // returns 4kthLargest.add(5);   // returns 5kthLargest.add(10);  // returns 5kthLargest.add(9);   // returns 8kthLargest.add(4);   // returns 8Note:  You may assume that nums‘length &gt;= k-1 and k &gt;= 1.  k는 KthLargest 생성자의 파라미터로 정해져 있다.  KthLargest.add 함수가 호출 될 때 마다 arr에 파라미터가 추가 되고, k번째 큰 숫자를 리턴한다.My Answer  Binary Search Tree를 이용하자.  cnt : 현재 노드를 루트로 하는 서브트리의 갯수, val : 현재 노드의 값, left : 왼쪽 노드, right : 오른쪽 노드를 멤버로 갖는 TreeNode 클래스를 추가하자.  KthLargest 생성자에서 nums를 이용해서 BST를 구성한다.  add 함수에선 파라미터로 넘어온값을 기존에 만들어 놓은 BST에 추가하고, k번째에 있는 숫자를 찾는다.  찾는 방식은 다음과 같다.          현재노드(curr)의 right가 null이 아니라면, right::cnt의 값이 k보다 같거나 큰지 확인한다.      만약 k보다 같거나 크다면, curr 보다 큰 숫자가 k만큼 있다는 것이니, 다음 curr은 curr.right가 된다.      만약 k보다 작다면, curr 보다 큰 숫자가 k 보다 적다는 것이니, k에서 right::cnt 만큼을 빼준다.                  위에서 뺀고난 이후 k가 1이라면 curr이 k번째 큰 숫자란 뜻.          k 가 1 보다 크다면, curr은 curr.left가 된다. 즉 이전 curr ~ curr::right 는 후보에서 제외되니까 k에 1을 추가로 빼준다.                    위 예제는 다음과 같은 흐름으로 된다.        k = 3BST =     4(4)   /   \\  2(1) 5(2)         \\          8(1)add(3):    4(6)   /   \\  2(2) 5(2)   \\    \\    3(1) 8(1)          1:    curr:4    5의 cnt = 2, k &gt; 5'cnt (2)    k = 3 - 2 = 1    k == 1, 4가 정답                    class TreeNode {    public int val;    public int cnt;    public TreeNode left;    public TreeNode right;        public TreeNode(int _val) {        val = _val;          cnt = 1;    }}class KthLargest {        int m_k;        TreeNode m_root;        public KthLargest(int k, int[] nums) {        m_k=k;            for(int n : nums)            insert(n);    }        public int add(int val) {        insert(val);                int k = m_k;        TreeNode curr = m_root;                while(curr != null) {            if ( curr.right != null ) {                if ( curr.right.cnt &gt;= k ) {                    curr = curr.right;                    continue;                } else {                    k -= curr.right.cnt;                                    }                            }                         if ( k == 1 ) {                                break;            } else {                k -= 1;                curr = curr.left;                            }        }                return curr.val;    }        void insert(int val) {        if ( m_root == null ) {            m_root = new TreeNode(val);        } else {               TreeNode curr = m_root;                        while ( curr != null ) {                curr.cnt++;                                boolean is_left = curr.val &gt;= val;                TreeNode next = is_left ? curr.left : curr.right;                                if ( next == null ) {                    if ( is_left ) {                        curr.left = new TreeNode(val);                                            } else {                        curr.right = new TreeNode(val);                    }                    curr = null;                } else {                    curr = next;                }                                        }                    }              }}Fastest Answer  Heap을 이용하자.          Heap이 뭐야?      완전 이진 트리를 배열로 표기 하기 위한 방법      부모 노드의 index는 자식 노드의 index를 2로 나눈 값이다.      특정 노드의 index가 i일때, 왼쪽 자식 노드의 index는 2*i+1, 오른쪽 자식 노드의 indexsms 2*i+2이다.             4   /   \\  2     7 / \\   / \\1   3 5   6=&gt; [4,2,7,1,3,5,6]=&gt;  0,1,2,3,4,5,64의 index=0, left(2)의 index=2*0+1=1, right(7)의 index=2*0+2=2   2의 index=1, left(1)의 index=2*1+1=3, right(3)의 index=2*1+2=47의 index=2, left(5)의 index=2*2+1=5, right(6)의 index=2*2+2=6                         heap의 첫번째 원소를 k만큼 큰 숫자로 유지하자.  addItem에서 현재 배열의 갯수가 k만큼 안될땐 siftUp 아니라면 siftDown을 호출class KthLargest {    final smallHeap heap;    public KthLargest(int k, int[] nums) {        heap = new smallHeap(k);        for (int i = 0; i &lt; nums.length; ++i) {            heap.addItem(nums[i]);        }    }        public int add(int val) {        heap.addItem(val);        return heap.peek();    }        private static class smallHeap {        int capacity;        int[] heap;        public smallHeap(int x) {            capacity = 0;            heap = new int[x];        }                public void addItem(int x) {            if (capacity &lt; heap.length) {                heap[capacity] = x;                siftUp(capacity);                capacity++;            } else {               if (x &gt; heap[0]) {                   heap[0] = x;                   siftDown(capacity);               }            }        }                private void siftUp(int i) {            while (i &gt; 0) {                int parent = (i-1)/2;                if (heap[i] &lt;= heap[parent]) {                    swapNum(i, parent);                    i = parent;                } else {                    return;                }            }        }                private void siftDown(int len) {            int cur = 0;            while (cur &lt; capacity/2) {                int left = cur * 2 + 1;                int right = cur * 2 +2;                int swap;                if (right &lt; len &amp;&amp; heap[right] &lt; heap[left])                    swap = right;                else                    swap = left;                if (heap[cur] &gt; heap[swap]) {                    swapNum(cur,swap);                    cur = swap;                } else {                    return;                }            }        }                private void swapNum(int x, int y) {            int temp = heap[x];            heap[x] = heap[y];            heap[y] = temp;        }                public int peek() {            return heap[0];        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/kth_largest_element_stream.html"
      }        
      ,
    
      "leetcode-2020-02-03-jewels-stones-html": {
        "title": "Jewels and Stones",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".Example 1:Input: J = \"aA\", S = \"aAAbbbb\"Output: 3Example 2:Input: J = \"z\", S = \"ZZ\"Output: 0Note:  S and J will consist of letters and have length at most 50.  The characters in J are distinct.My Answer  HashSet을 이용하자.  J를 순회하면서, 문자를 HashSet에 저장하고, S를 순회하면서 HashSet에 포함되어 있는지 확인.class Solution {    public int numJewelsInStones(String J, String S) {        Set&lt;Character&gt; hashset = new HashSet&lt;&gt;();                for(int i=0;i&lt;J.length();i++) {            hashset.add(J.charAt(i));        }                int total = 0;        for(int i=0;i&lt;S.length();i++) {            if ( hashset.contains(S.charAt(i))) total++;        }                return total;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/jewels_stones.html"
      }        
      ,
    
      "leetcode-2020-02-03-isomorphic-strings-html": {
        "title": "Isomorphic Strings",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.Example 1:Input: s = \"egg\", t = \"add\"Output: trueExample 2:Input: s = \"foo\", t = \"bar\"Output: falseExample 3:Input: s = \"paper\", t = \"title\"Output: trueNote :  You may assume both s and t have the same length.My Answer  HashMap을 이용하자. HashMap의 키는 s의 문자, 값은 t의 문자를 넣자.  s를 순회 하면서, 문자가 HashMap의 키로 포함되어 있는지 확인하자.  만약 키로 포함되어 있으면서, 값이 t의 문자와 다르다면 false  만약 키로 포함되어 있지 않은데, t의 문자가 값으로 HashMap에 포함되어 있다면 false  위 조건을 만족하지 않는다면, HashMap에 넣고 다음 순회.  반복해서 돌았는데, false가 발생하지 않는다면, true이다.class Solution {    public boolean isIsomorphic(String s, String t) {        Map&lt;Character, Character&gt; hashmap = new HashMap&lt;&gt;();                for(int i=0;i&lt;s.length(); i++) {            char s_c = s.charAt(i);                        if ( hashmap.containsKey(s_c) ) {                if ( hashmap.get(s_c) != t.charAt(i)) return false;            } else {                if ( hashmap.containsValue(t.charAt(i))) return false;                                hashmap.put(s_c, t.charAt(i));                           }                     }                return true;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/isomorphic_strings.html"
      }        
      ,
    
      "leetcode-2020-02-03-intersection-of-two-arrays-ii-html": {
        "title": "Intersection of Two Arrays II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven two arrays, write a function to compute their intersection.Note:  Each element in the result should appear as many times as it shows in both arrays.  The result can be in any order.Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]My Answer  nums1, nums2 중에 갯수가 작은 것 기준으로 순회하자.  갯수가 작은것과 큰것을 따로 구분해서 lower, higher 라는 이름의 배열을 사용하자.  결과를 담을 리스트와 이미 체크한 higher의 index를 담을 Set을 선언하자  lower 기준으로 순회 하면서 higher의 원소와 같은지 확인 하고, 이미 Set에 저장된 index라면 볼것도 없이 continueclass Solution {    public int[] intersect(int[] nums1, int[] nums2) {        if ( nums1.length == 0)             return nums1;                if ( nums2.length == 0)            return nums2;                int[] lower = nums1.length &gt; nums2.length ? nums2 : nums1;        int[] higher = nums1.length &gt; nums2.length ? nums1 : nums2;                ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();        Set&lt;Integer&gt; checked_index = new HashSet&lt;&gt;();                     long n_checked_index = 0;        for(int i = 0; i &lt; lower.length; i++) {            int n_1 = lower[i];            for(int j = 1;j&lt;= higher.length; j++) {                if ( checked_index.contains(j))                    continue;                                int n_2 = higher[j-1];                if ( n_1 == n_2) {                    arrayList.add(n_1);                    checked_index.add(j);                    break;                }            }        }                    \t\t        return arrayList.stream().mapToInt(Integer::intValue).toArray();    }}My Answer ( Use HashMap )  HashMap을 이용하자.  nums1을 순회하면서, nums1[i]을 HashMap의 키로, nums1[i]의 발생횟수를 값으로 할당하자.  nums2를 순회하면서, HashMap에 nums2[i]가 키로 포함되어 있고, 해당 값이 1이상 이라면, 해당 값을 1빼고, 정답 갯수를 의미 하는 k를 증가 시키면서 nums1[k]를 nums2[i]로 대체하자.  nums1[0~k-1]까지를 결과 배열로 옮기자.class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        Map&lt;Integer, Integer&gt; hashmap = new HashMap&lt;&gt;();                for(int i=0;i&lt;nums1.length;i++) {       //각 숫자의 발생횟수 기록            hashmap.put(nums1[i], hashmap.getOrDefault(nums1[i], 0) + 1);        }                int k=0;    //intersection이 발생하는 갯수        for(int i=0;i&lt;nums2.length;i++) {            if ( !hashmap.containsKey(nums2[i])) continue;            if ( hashmap.get(nums2[i]) &lt;= 0 ) continue;     //발생횟수가 0이하라는것은 이미 결과 배열에 기록 했다는 의미이다.                        hashmap.put(nums2[i], hashmap.get(nums2[i]) - 1);   //발생횟수를 1 빼주자.             nums1[k++] = nums2[i];                        if ( k &gt;= nums1.length ) break;     //k가 nums1의 갯수만큼 됬다는건 이 이후에 더 돌아봐야 intersection은 없다는 의미이다. nums1.length &lt; nums2.length 일때 의미 있다.        }                if ( k == nums1.length ) {            return nums1;        } else {            int[] result = new int[k];            System.arraycopy(nums1, 0, result, 0, k);            return result;        }                }}Fastest Answer  nums1, nums2를 정렬, 1차 결과를 담을 배열(result)선언 사이즈는 nums1로 하든 nums2로 하든 상관없다.  nums1, nums2를 둘다 다 순회 할때 까지 while  만약 같으면 result에 담고 i, j, k 증가.  만약 nums1이 더 작다면 i만 증가.  최종 결과를 담을 배열(res)선언 1차 결과 배열에서 중첩된 갯수만 최종 결과로 옮겨 담는다.class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        int[] result = new int[nums1.length];                int i = 0;        int j = 0;        int k = 0;        Arrays.sort(nums1);        Arrays.sort(nums2);                while(i&lt;nums1.length &amp;&amp; j &lt; nums2.length){            if(nums1[i] == nums2[j]){                result[k] = nums1[i];                k++;                i++;                j++;            }else if(nums1[i] &lt; nums2[j]){                i++;            }else{                j++;            }                    }                int[] res = new int[k];                for(int l=0; l&lt;k; l++){            res[l] = result[l];        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/intersection_of_two_arrays_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-intersection-of-two-arrays-html": {
        "title": "Intersection of Two Arrays",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven two arrays, write a function to compute their intersection.Note:  Each element in the result must be unique  The result can be in any order.Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4]My Answer 1  nums1, nums2 배열을 오름차순으로 정렬 한다.  두개의 배열중 갯수가 적은 것을 기준으로 반복 돌면서 nums2에서 일치 하는것을 찾는다.  만약 이전 반복에서 체크했던 값과 같을경우는 넘어간다.class Solution {    public int[] intersection(int[] nums1, int[] nums2) {        int[] result;        if ( nums1.length &lt; nums2.length ) {            result = intersectionArray(nums1, nums2);        } else {            result = intersectionArray(nums2, nums1);        }                return result;    }        int[] intersectionArray(int[] nums1, int[] nums2) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        Arrays.sort(nums1);        Arrays.sort(nums2);                for(int i=0; i&lt; nums1.length;i++) {            if ( i &gt; 0 &amp;&amp; nums1[i] == nums1[i-1])                continue;                        int l=0;            int r=nums2.length-1;                        while(l &lt; r ) {                int mid = (l+r)/2;                if ( nums2[mid] == nums1[i]) {                    l = mid;                    break;                }                                if ( nums2[mid] &lt; nums1[i]) {                    l = mid + 1;                } else {                    r = mid - 1;                }            }                        if ( nums2[l] == nums1[i]) {                result.add(nums1[i]);            }        }                int[] array = new int[result.size()];        int i = 0;        for(int x : result)            array[i++] = x;        return array;    }}My Answer 2  i,j,k를 각각 nums1의 index, nums2의 index, temp_res의 index이자 결과 리스트에 넣을 index 로 활용하자.  nums1, nums2 배열을 오름차순으로 정렬 한다.  nums1[i] == nums2[j]일 경우, 결과 리스트에 넣을 기본 조건에 만족 한다. 추가로, k가 0보다 클땐 temp_res[k-1]과 다른지 확인 필요하다. 중첩된 값을 결과 리스트에 넣을 수 없기 때문에.  nums1[i] &lt;= nums2 일땐 i를 증가 시키고, nums1[i] &gt;= nums2[j] 일땐 j를 증가 시키자.  최종적으로 temp_res에 있는 값들중 k만큼만 새로운 결과 배열에 옮겨 담으면 된다.class Solution {    public int[] intersection(int[] nums1, int[] nums2) {        int i=0;        int j=0;        int k=0;        int[] temp_res = new int[nums1.length];                Arrays.sort(nums1);        Arrays.sort(nums2);                while(i &lt; nums1.length &amp;&amp; j &lt; nums2.length ) {            if ( nums1[i] == nums2[j] &amp;&amp; (k == 0 || (k &gt; 0 &amp;&amp; temp_res[k-1] != nums1[i])) ) {                temp_res[k++] = nums1[i];                                i++;                j++;            } else if ( nums1[i] &lt;= nums2[j]) {                            i++;            } else if ( nums1[i] &gt;= nums2[j]) {                j++;            }        }                int[] res = new int[k];        for(int t=0;t&lt;k;t++) {            res[t] = temp_res[t];        }                return res;            }    }My Answer ( Use HashSet )  nums1을 순회하면서 HashSet에 넣자.  nums2를 순회하면서 중복된 값이 있는지 확인하고, 중복된 값이 있다면, nums1의 앞에서 부터 덮어 쓰면서 중복된 값의 갯수를 k에 저장.  nums1의 0~k-1의 값이 최종 결과class Solution {    public int[] intersection(int[] nums1, int[] nums2) {        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();                Arrays.sort(nums2);                int i=0;        while(i &lt; nums1.length ) {            if ( !hashSet.contains(nums1[i]) )                hashSet.add(nums1[i]);                        i++;        }                i=0;        int k=0;        while(i &lt; nums2.length ) {            if ( hashSet.contains(nums2[i])) {                if ( k == 0 || nums1[k-1] != nums2[i]) {                    nums1[k++] = nums2[i];                        }            }            i++;        }                int[] result = new int[k];        System.arraycopy(nums1, 0, result, 0, k);                return result;    }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/intersection_of_two_arrays.html"
      }        
      ,
    
      "leetcode-2020-02-03-insert-into-binary-search-tree-html": {
        "title": "Insert into a Binary Search Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.Example :Input:         4       / \\      2   7     / \\    1   3    insert : 5Output:          4       /   \\      2     7     / \\   /    1   3 5My Answer ( Iteration )  만약 root가 null이라면, val을 이용해서 새로운 root를 만들고 반환  leaf노드가 null인 노드를 찾고 해당 노드의 left혹은 right에 새로운 노드를 만든다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if ( root == null ) {            root = new TreeNode(val);            return root;        }                TreeNode curr = root;                while ( curr != null ) {            boolean is_left = curr.val &gt; val;            TreeNode next = is_left ? curr.left : curr.right;                         if ( next == null ) {                if ( is_left ) curr.left = new TreeNode(val);                else curr.right = new TreeNode(val);                break;            } else {                curr = next;            }                    }                return root;    }}My Answer ( Recursive )  재귀를 이용해서 해결/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if ( root == null ) {            root = new TreeNode(val);            return root;        }                _insertIntoBST(root, val);                return root;    }        void _insertIntoBST(TreeNode root, int val) {        boolean is_left = root.val &gt; val;        TreeNode next = is_left ? root.left : root.right;                     if ( next == null ) {            if ( is_left ) root.left = new TreeNode(val);            else root.right = new TreeNode(val);            return;        }                if ( is_left ) {            insertIntoBST(root.left, val);        } else {            insertIntoBST(root.right, val);        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/insert_into_binary_search_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-implement-trie-html": {
        "title": "Implement Trie (Prefix Tree)",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemImplement a trie with insert, search, and startsWith methods.Example :Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\");   // returns truetrie.search(\"app\");     // returns falsetrie.startsWith(\"app\"); // returns truetrie.insert(\"app\");   trie.search(\"app\");     // returns trueNote :  You may assume that all inputs are consist of lowercase letters a-z  All inputs are guaranteed to be non-empty stringsMy Answerclass TrieNode {    public boolean is_leaf;    TrieNode[] children = new TrieNode[26];            boolean containsKey(char c) {        return children[c - 'a'] != null;    }        TrieNode get(char c) {        return children[c - 'a'];    }        void put(char c, TrieNode node) {        children[c - 'a'] = node;    }}class Trie {    TrieNode m_root;    /** Initialize your data structure here. */    public Trie() {        m_root = new TrieNode();    }        /** Inserts a word into the trie. */    public void insert(String word) {                TrieNode cur = m_root;                for(char c : word.toCharArray()) {            if ( !cur.containsKey(c)) {                cur.put(c, new TrieNode());            }                         cur = cur.get(c);         }                cur.is_leaf = true;    }        /** Returns if the word is in the trie. */    public boolean search(String word) {        TrieNode cur = m_root;                for(char c : word.toCharArray()) {            if ( !cur.containsKey(c))                return false;                        cur = cur.get(c);                 }                return cur.is_leaf;    }        /** Returns if there is any word in the trie that starts with the given prefix. */    public boolean startsWith(String prefix) {        TrieNode cur = m_root;                for(char c : prefix.toCharArray()) {                        if ( !cur.containsKey(c))                return false;                        cur = cur.get(c);                 }                return true;    }}/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */",
        "url": "http://localhost:4000//leetcode/2020/02/03/implement_trie.html"
      }        
      ,
    
      "leetcode-2020-02-03-happy-number-html": {
        "title": "Happy Number",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWrite an algorithm to determine if a number is “happy”.A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.Example 1:Input: 19Output: trueExplanation: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1    My Answer  HashSet을 이용하자.  자릿수마다 제곱수를 구한 후 전부 합하면 다음 반복수행때 사용할 n이 된다.  n은 HashSet에 넣어 주자.  만약 n이 HashSet에 이미 있다는건, 반복 싸이클이 돈다는걸 의미 한다.  만약 n이 1이면 HappyNumber이다.class Solution {    public boolean isHappy(int n) {        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();                while(!hashSet.contains(n)) {            hashSet.add(n);            n = getSquareSum(n);                        if ( n == 1 ) return true;        }        return false;    }        int getSquareSum(int n) {        int res = 0;        while( n &gt; 0 ) {            int digit = n % 10;            res += digit * digit;            n /= 10;        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/happy_number.html"
      }        
      ,
    
      "leetcode-2020-02-03-guess-number-higher-or-lower-html": {
        "title": "Guess Number Higher or Lower",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemWe are playing the Guess Game. The game is as follows:I pick a number from 1 to n. You have to guess which number I picked.Every time you guess wrong, I’ll tell you whether the number is higher or lower.You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it!Example :Input: n = 10, pick = 6Output: 6My Answer  1~n까지 분할해서 찾자.  l은 최소값, r은 최대값이다. while문에서는 l+r의 중간값 ( mid )를 찾고 mid가 찾는 값인지 guess함수로 확인한다.  만약 guess함수의 리턴값이 0이면 답을 찾았으니 끝내고, -1이면 mid보다 작은 값을 찾아야 하니 r에 mid를 할당하고 다음 반복 수행, 1이면 mid보다 큰 값이니까 l에 mid+한 값을 할당하고 반복 수행 하면된다.  예를 들어 다음과 같은 흐름으로 진행된다.      Input: n = 10, pick = 7  1:      l=1, r=10, mid=5, guess(5)=1  2:      l=6, r=10, mid=8, guess(8)=-1  3:      l=6, r=8, mid=7, guess(7)=0      /* The guess API is defined in the parent class GuessGame.   @param num, your guess   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0      int guess(int num); */public class Solution extends GuessGame {    public int guessNumber(int n) {        int l = 1;        int r = n;                int res = 0;                while( l &lt;= r) {                        int mid = l + ((r - l)&gt;&gt;1); // `(l+r)/2` 은 할 수 없다. l+r이 int의 범위를 넘을 수 있기 때문에.            int g = guess( mid );                        if ( g == 0 ) {                res = mid;                break;            } else if ( g == 1) {                l = mid + 1;            } else {                r = mid;            }        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/guess_number_higher_or_lower.html"
      }        
      ,
    
      "leetcode-2020-02-03-group-anagrams-html": {
        "title": "Group Anagrams",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of strings, group anagrams together.Example :Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],Output:[  [\"ate\",\"eat\",\"tea\"],  [\"nat\",\"tan\"],  [\"bat\"]]Note:  All inputs will be in lowercase.  The order of your output does not matter.My Answer  HashMap을 이용하자. 문자열의 정렬된 형태의 문자열을 키로 하고, 문자열의 리스트를 값으로 할당.  strs를 순회하면서, strs[i]를 정렬한다.  정렬된 strs[i]가 HashMap의 키로 존재 하는지 확인 하고, 없다면 List&lt;String&gt;을 만들어서 HashMap과 결과 리스트에 추가 한다. List&lt;String&gt;를 참조 타입이기 때문에 수정하기 용이 하다.  HashMap에서 정렬된 strs[i]의 값에 strs[i]를 넣으면 된다.class Solution {    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();        Map&lt;String, List&lt;String&gt;&gt; hashmap = new HashMap&lt;&gt;();                for ( String s : strs ) {            char[] arr = s.toCharArray();                        Arrays.sort(arr);                        String sorted_str = new String(arr);                        if ( !hashmap.containsKey(sorted_str) ) {                List&lt;String&gt; sub_result = new ArrayList&lt;&gt;();                                hashmap.put(sorted_str, sub_result);                result.add(sub_result);                            }                        hashmap.get(sorted_str).add(s);        }                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/group_anagrams.html"
      }        
      ,
    
      "leetcode-2020-02-03-generate-parenthesis-html": {
        "title": "Generate Parenthesis",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.Example :Input: 3Output:[  \"((()))\",  \"(()())\",  \"(())()\",  \"()(())\",  \"()()()\"]My Answer ( Recursive )  재귀를 이용해서 해결class Solution {    public List&lt;String&gt; generateParenthesis(int n) {        List&lt;String&gt; result = new ArrayList();        backtrack(result, \"\", 0, 0, n);        return result;    }    public void backtrack(List&lt;String&gt; result, String cur, int open, int close, int max){        if (cur.length() == max * 2) {            result.add(cur);            return;        }        if (open &lt; max)                        backtrack(result, cur+\"(\", open+1, close, max);                    if (close &lt; open)                        backtrack(result, cur+\")\", open, close+1, max);                }}My Answer ( Iteration )  다음과 같은 알고리즘이 나온다      f(0) = Empty  f(1) = ()  f(2) = ()() = () + f(1)         (()) = ( f(1) )  f(3) = ()()() = (f(0)) + f(2_1)         ()(()) = (f(0)) + f(2_2)         (())() = (f(1)) + f(1)         (()()) = (f(2_1)) + f(0)         ((())) = (f(2_2)) + f(0)  first_sol = sol(0 ~ n - 1)  second_sol = sol(n - 1 ~ 0)  for(String x : first_sol)      for(String y : second_sol)          sol(n).add( (+ x +) + y )        0번째와 1번째는 미리 Solutions에 넣어 줬다.class Solution {    public List&lt;String&gt; generateParenthesis(int n) {        List&lt;List&lt;String&gt;&gt; solutions = new ArrayList&lt;List&lt;String&gt;&gt;();                List&lt;String&gt; l_zero = new ArrayList();        l_zero.add(\"\");        solutions.add(l_zero);                List&lt;String&gt; l_one = new ArrayList();        l_one.add(\"()\");        solutions.add(l_one);                        for ( int i = 2; i &lt;= n; i++ ) {            int x_idx = 0;            int y_idx = i-1;                        List&lt;String&gt; sol = new ArrayList();                        while(x_idx &lt; i) {                List&lt;String&gt; first = solutions.get(x_idx);                List&lt;String&gt; second = solutions.get(y_idx);                                for(String x : first) {                    for(String y : second ) {                        sol.add(String.format(\"(%s)%s\", x, y));                        }                }                x_idx++;                y_idx--;            }                        solutions.add(sol);        }                return solutions.get(n);    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/generate_parenthesis.html"
      }        
      ,
    
      "leetcode-2020-02-03-first-unique-char-in-string-html": {
        "title": "First Unique Character in s String",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.Example 1:Input: \"leetcode\"Output: 0Example 2:Input: \"loveleetcode\"Output: 2Note :  You mau assume the string contain only lowercase letters.My Answer  HashMap을 이용하자. s를 순회하면서, 문자의 발생횟수를 HashMap의 값으로 넣자.  이후 s를 순회하면서, HashMap의 값이 1인것이 나오면 해당 index가 정답이다.class Solution {    public int firstUniqChar(String s) {        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();        int n = s.length();                for (int i = 0; i &lt; n; i++) {            char c = s.charAt(i);            count.put(c, count.getOrDefault(c, 0) + 1);        }                for (int i = 0; i &lt; n; i++) {            if ( count.get(s.charAt(i)) == 1)                return i;        }                return -1;    }}Fastest Answer  소문자 문자 [a~z]만 포함되기 때문에, s에서 각 문자가 위치하고 있는 가장 작은 index와 가장 큰 index를 찾자.  만약 가장 작은 index가 -1이면, 해당 문자는 s에 없다는 뜻.  만약 가장 작은 index와 가장 큰 index가 같다면, 해당 문자는 s에서 하나만 있다는 뜻.  위의 조건을 만족하는 것들중 가장 작은 index값이 정답.class Solution {    public int firstUniqChar(String s) {                int min_index = -1;                for(char c='a'; c&lt;= 'z'; c++) {            int first = s.indexOf(c);            int last = s.lastIndexOf(c);                        if ( first == -1 || first != last ) continue;                            min_index = min_index == -1 || min_index &gt; first ? first : min_index;        }                return min_index;            }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/first_unique_char_in_string.html"
      }        
      ,
    
      "leetcode-2020-02-03-first-bad-version-html": {
        "title": "First Bad Version",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.Example :Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. My Answer  isBadVersion함수의 리턴값이 true인 최소 값을 찾자.  중간값 (mid)을 이용해서 isBadVersion의 결과값을 확인해서 true이면 res에 mid를 저장해 놓고, low~mid-1을 확인하자.  만약 isBadVersion의 결과값이 false라면 mid값 보다 큰 영역에 찾는 값이 있다는 뜻이므로 mid+1~ high를 확인 하자./* The isBadVersion API is defined in the parent class VersionControl.      boolean isBadVersion(int version); */public class Solution extends VersionControl {    public int firstBadVersion(int n) {        int low = 1;        int high = n;        int res = -1;                while(low &lt;= high) {            int mid = low + ((high-low)&gt;&gt;1);                        if ( isBadVersion(mid) ) {                res = mid;                high = mid -1;            } else {                low = mid + 1;            }                    }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/first_bad_version.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-smallest-letter-greater-target-html": {
        "title": "Find Smallest Letter Greater than Target",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’.Note:  letters has a length in range [2, 10000].  letters consists of lowercase letters, and contains at least 2 unique letters.  target is a lowercase letter.Example:Input:letters = [\"c\", \"f\", \"j\"]target = \"a\"Output: \"c\"Input:letters = [\"c\", \"f\", \"j\"]target = \"c\"Output: \"f\"Input:letters = [\"c\", \"f\", \"j\"]target = \"d\"Output: \"f\"Input:letters = [\"c\", \"f\", \"j\"]target = \"g\"Output: \"j\"Input:letters = [\"c\", \"f\", \"j\"]target = \"j\"Output: \"c\"Input:letters = [\"c\", \"f\", \"j\"]target = \"k\"Output: \"c\"My Answer  low, high index를 이용해서 중간값 mid를 찾고 target보다 큰 문자 인지 확인  만약 letters[mid]가 target보다 크면, high에 mid를 할당  만약 letters[mid]가 target과 같거나 작으면, low에 mid+1을 할당한다.  letters[low]가 정답인데, letters[low]가 target과 같거나 작은 경우가 발생할 수 있기 때문에 다음과 같이 보정해 준다.          low를 하나 증가 시킨다.      만약 low가 letters.length 와 같아지면 low를 0으로 할당해 준다.      class Solution {    public char nextGreatestLetter(char[] letters, char target) {        int low=0;        int high=letters.length-1;                while(low &lt; high) {            int mid = (low + high)/2;                        if ( letters[mid] &gt; target ) {                high = mid;            } else {                low = mid +1;            }                    }                if ( letters[low] &lt;= target ) {            low++;            if ( low &gt;= letters.length ) {                low = 0;            }        }                return letters[low];    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_smallest_letter_greater_target.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-peak-element-html": {
        "title": "Find Peak Element",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemA peak element is an element that is greater than its neighbors.Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.You may imagine that nums[-1] = nums[n] = -∞.Example 1:Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.Example 2:Input: nums = [1,2,1,3,5,6,4]Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2,              or index number 5 where the peak element is 6.Note:Your solution should be in logarithmic complexity.My Answer  중간값을 이용해서 찾자.  l과 r을 이용해서 중간 index(mid)를 찾고 nums[mid]와 nums[mid+1]이 만족하는지 확인하자. 만족 한다면 peek 조건의 우측항은 만족 했다는 의미.  우측항이 만족했다면, 좌측항이 만족 하는지 확인 하기 위해서 r에 mid를 할당한다.  좌측항이 만족했다면, l에 mid + 1을 할당한다.  최종 결과는 l이 된다.  예를 들어 다음과 같은 흐름이 된다.      Input: nums = [1,2,3,1]  1:      l=0, r=3, mid=1,      nums[mid]=2, nums[mid+1]=3,      nums[mid] &lt; nums[mid+1] = 좌측항 만족, 우측항 확인 위해 l=mid+1  2:      l=2, r=3, mid=2,      nums[mid]=3, nums[mid+1]=1,      nums[mid] &gt; nums[mid+1] = 우측항 만족, 좌측항 확인 위해 r=mid  3:       l=2, r=2, r이 l보다 크지 않기 때문에 반복 종료, 결과는 2      class Solution {    public int findPeakElement(int[] nums) {        int l = 0;        int r = nums.length - 1;                while ( l &lt; r ) {            int mid = (l + r)&gt;&gt;1;                        if ( nums[mid] &gt; nums[mid +1]) {                r = mid;                            } else {                l = mid + 1;            }                     }                return l;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_peak_element.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-minimum-in-rotated-sorted-array-ii-html": {
        "title": "Find Minimum in Rotated Sorted Array II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).Find the minimum element.The array may contain duplicates.Example 1:Input: [1,3,5]Output: 1Example 2:Input: [2,2,2,0,1]Output: 0Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array  Would allow duplicates affect the run-time complexity? How and why?My Answer  중간값을 이용해서 찾자.  만약 i와 j인덱스가 다른데 값이 같다면 i를 증가 시키자 [2,4,5,1,2] 이런 케이스때문에.  오름차순이기 때문에, nums[i]가 nums[j]보다 작거나 같으면 nums[i]가 제일 작은 값이다.  만약 그렇지 않다면, 중간값을 이용해서 범위를 줄이자.class Solution {    public int findMin(int[] nums) {        int i=0;        int j=nums.length-1;        while(i&lt;=j){            while(nums[i]==nums[j] &amp;&amp; i!=j){                i++;            }            if(nums[i]&lt;=nums[j]){                return nums[i];            }            int m=(i+j)/2;            if(nums[m]&gt;=nums[i]){                i=m+1;            }else{                j=m;            }        }        return -1;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_minimum_in_rotated_sorted_array_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-minimum-in-rotated-sorted-array-html": {
        "title": "Find Minimum in Rotated Sorted Array",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).Find the minimum element.You may assume no duplicate exists in the array.Example 1:Input: [3,4,5,1,2] Output: 1Example 2:Input: [4,5,6,7,0,1,2]Output: 0My Answer  중간값을 이용해서 찾자.  l과 r을 이용해서 중간 index(mid)를 찾고 min과 nums[mid] 중 작은값을 min에 할당하자.  회전되어 있는 상황인지 확인 하기 위해서, 다음과 같은 조건검사를 한다.  ```java          nums[l] &lt; nums[mid] &amp;&amp; nums[r] &gt; nums[mid] =&gt; l -&gt; mid -&gt; r =&gt; 최소 값이 mid 보다 앞에 있다.      nums[l] &lt; nums[mid] &amp;&amp; nums[r] &lt; nums[mid] =&gt; l -&gt; mid &lt;- l =&gt; 최소 값이 mid 보다 뒤에 있다.      nums[l] &gt; nums[mid] &amp;&amp; nums[r] &gt; nums[mid] =&gt; l &lt;- mid -&gt; r =&gt; 최소 값이 mid 보다 앞에 있다.      nums[l] &gt; nums[mid] &amp;&amp; nums[r] &lt; nums[mid] =&gt; l &lt;- mid &lt;- l =&gt; 최소 값이 mid 보다 뒤에 있다.  ```      class Solution {    public int findMin(int[] nums) {        int l=0;        int r=nums.length-1;        int min = Integer.MAX_VALUE;                while( l &lt;= r ) {            int mid = (l + r)/2;                        min = Math.min(nums[mid], min);                        if ( nums[l] &lt; nums[mid]) {                if ( nums[r] &gt; nums[mid]) {                    r = mid - 1;                } else {                    l = mid + 1;                }            } else {                if ( nums[r] &gt; nums[mid]) {                    r = mid - 1;                                                        } else {                    l = mid + 1;                                    }            }        }                return min;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_minimum_in_rotated_sorted_array.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-k-th-smallest-pair-distance-html": {
        "title": "FInd K-th Smallest Pair Distance",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.Example :Input:nums = [1,3,1]k = 1Output: 0 Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1st smallest distance pair is (1,1), and its distance is 0.Note:  2 &lt;= len(nums) &lt;= 10000.  0 &lt;= nums[i] &lt; 1000000.  1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.Solution  lo, hi는 각각 최소 거리와 최대 거리를 의미 한다. nums의 가장 마지막 원소에서 첫번째 원소를 뺀 만큼이 최대 거리이다.  for (int right = 0; right &lt; nums.length; ++right) 에서 현재 중간거리(mi)와 같거나 작은 거리의 갯수를 구한다. 예를들어 다음과 같은 흐름으로 계산 된다.      Input : [1,2,4,5], k=3  lo=0, hi=5-1=4  1:      mi=(0+4)/2=2      1-1:          nums[1] - nums[0] = 2-1 = 1 &lt; mi          count += 1 - 0      1-2:          nums[2] - nums[0] = 4-1 = 3 &gt; mi          nums[2] - nums[1] = 4-2 = 2 = mi                      count += 2 - 1      1-3:          nums[3] - nums[1] = 5-2 = 3 &gt; mi          nums[3] - nums[2] = 5-4 = 1 &lt; mi          count += 3 - 2      count=3      //mi=2 보다 같거나 작은 경우의 수      //(1,2), (4,5), (2,4) = 3개              count &gt;= 3      hi=2        count가 k보다 같거나 크다면, 최대거리(hi)에 중간거리(mi)를 할당하고 k보다 작다면 최소거리(lo)에 중간거리(mi) + 1을 할당 하자. 위 코드에서 이어서 수행하면 다음과 같이 계산된다.      Input : [1,2,4,5], k=3  lo=0, hi=2  1:      mi=(0+2)/2=1      1-1:          nums[1] - nums[0] = 2-1 = 1 = mi          count += 1 - 0      1-2:          nums[2] - nums[0] = 4-1 = 3 &gt; mi          nums[2] - nums[1] = 4-2 = 2 &gt; mi                      nums[2] - nums[2] = 4-4 = 0 &lt; mi                      count += 2 - 2      1-3:          nums[3] - nums[2] = 5-4 = 1 = mi          count += 3 - 2      count=2      //mi=1 보다 같거나 작은 경우의 수      //(1,2), (4,5) = 2개      count&lt;3      lo=mi+1=2        최종적으로 lo가 k번째 작은거리이다.class Solution {    public int smallestDistancePair(int[] nums, int k) {        Arrays.sort(nums);        int lo = 0;        int hi = nums[nums.length - 1] - nums[0];        while (lo &lt; hi) {            int mi = (lo + hi) / 2;            int count = 0, left = 0;            for (int right = 0; right &lt; nums.length; ++right) {                while (nums[right] - nums[left] &gt; mi) {                  left++;                  }                                 count += right - left;            }            //count = number of pairs with distance &lt;= mi            if (count &gt;= k) hi = mi;            else lo = mi + 1;        }        return lo;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_k_th_smallest_pair_distance.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-k-closest-elements-html": {
        "title": "Find K Closest Elements",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.Example 1:Input: [1,2,3,4,5], k=4, x=3Output: [1,2,3,4]Example 2:Input: [1,2,3,4,5], k=4, x=-1Output: [1,2,3,4]Note:  The value k is positive and will always be smaller than the length of the sorted array.  Length of the given array is positive and will not exceed 10^4  Absolute value of elements in the array and x will not exceed 10^4My Answer  x와 가장 가까운 연속된 원소 k개를 찾는 문제.  만약 첫번째 원소가 x와 같거나 크면 arr[0~k]가 정답  만약 마지막 원소가 x와 같거나 작으면 arr[length-k~count]가 정답  위 조건들을 만족 하지 않을 경우엔 다음과 같다.          x와 같거나 가장 가까운 값의 index를 찾는다.      start는 0 혹은 index-k 중에 큰 값으로 한다.      end는 arr.length - 1 혹은 index+k중에 작은 값으로 한다.      start ~ end의 갯수가 k가 될때 까지 반복한다.      만약 arr[end]-x가 x-arr[start]보다 크면, 앞쪽이 더 x에 가깝다는 것이니 end를 하나 줄인다.      만약 arr[end]-x가 x-arr[start]보다 작으면, 뒷쪽이 더 x에 가깝다는 것이니 start를 하나 늘린다.      만약 arr[end]-x와 x-arr[start]가 같다면, 임의로 end를 하나 줄인다.      class Solution {    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();                int count = arr.length;                for(int i=0; i&lt;count;i++) {            result.add(arr[i]);        }                int start = 0;        int end = count;                if ( arr[0] &gt;= x ) {            result = result.subList(0, k);        } else if ( arr[count - 1] &lt;= x) {            result = result.subList(count - k, count);        } else {            int index = searchIndex(arr, x);                        start = Math.max(0, index-k);            end = Math.min(count - 1, index+k);                        while( end-start+1 != k ) {                if ( arr[end]-x &gt; x - arr[start]) {                    end--;                } else if ( arr[end]-x &lt; x - arr[start]) {                    start++;                } else {                    end--;                }            }                        result = result.subList(start, end+1);        }                return result;    }        int searchIndex(int[] arr, int target) {        int l=0;        int h=arr.length-1;                while( l &lt; h ) {            int mid = (l+h)/2;                        if ( arr[mid] == target ) {                return mid;            }                        if ( arr[mid] &lt; target ) {                l = mid+1;            } else {                h=mid;            }        }                return l;    }}Fastest Answer  재귀를 이용  만약 x-arr[mid]가 arr[mid+k]-x보다 크면, 우측이 더 x에 가깝다는것이니 우측영역에서 다시 찾는다.  만약 x-arr[mid]가 arr[mid+k]-x보다 작거나 같으면, 좌측이 더 x에 가깝다는것이니 좌측영역에서 다시 찾는다.class Solution {    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) {        return find(arr, 0, arr.length - k, k, x);    }        private List&lt;Integer&gt; find(int[] arr, int left, int right, int k, int x) {        if(left == right) {            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            for(int i = left; i &lt; left + k; i++) list.add(arr[i]);            return list;        }        int mid = (left + right) / 2;        if(x - arr[mid] &gt; arr[mid + k] - x)            return find(arr, mid + 1, right, k, x);        else            return find(arr, left, mid, k, x);    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_k_closest_elements.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-duplicate-subtrees-html": {
        "title": "Find Duplicate Subtrees",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.Two trees are duplicate if they have the same structure with same node values.Example :        1       / \\      2   3     /   / \\    4   2   4       /      4The following are two duplicate subtrees.      2     /    4and    4Solution  HashMap을 이용하자. 각 TreeNode별로 고유값을 반환할 lookup함수를 이용.  lookup함수에선, 각 TreeNode별 고유문자열을 만들고 이것을 키로 하고, 고유문자열에 대응되는 번호를 매겨서 값으로 사용하는 HashMap trees를 사용  trees의 값 별로 발생 횟수를 저장할 HashMap count를 사용  만약 count의 값이 2라면, 중복 발생했다는 의미 이기 때문에, 결과 리스트에 추가/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    int t;                          //고유 번호를 생성하기 위한 변수    Map&lt;String, Integer&gt; trees;     //각 TreeNode의 고유 문자열, 고유 번호    Map&lt;Integer, Integer&gt; count;    //각 TreeNode의 고유 번호, 발생 횟수    List&lt;TreeNode&gt; ans;             //결과 리스트    public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) {        t = 1;        trees = new HashMap();        count = new HashMap();        ans = new ArrayList();        lookup(root);        return ans;    }    public int lookup(TreeNode node) {        if (node == null) return 0;        /*        1. 고유 문자열 생성, 현재 TreeNode::val + \",\" + TreeNode::left의 고유번호 + \",\" + TreeNode::right의 고유번호        2. 고유 문자열을 이용한 고유번호 생성 및 trees에 기록        3. 고유번호의 발생 횟수 기록        4. 고유번호의 발생 횟수가 2이면 정답        */        String serial = node.val + \",\" + lookup(node.left) + \",\" + lookup(node.right);                int uid = trees.computeIfAbsent(serial, x-&gt; t++);        count.put(uid, count.getOrDefault(uid, 0) + 1);        if (count.get(uid) == 2)            ans.add(node);        return uid;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_duplicate_subtrees.html"
      }        
      ,
    
      "leetcode-2020-02-03-find-duplicate-number-html": {
        "title": "Find Duplicate Number",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.Example 1:Input: [1,3,4,2,2]Output: 2Example 2:Input: [3,1,3,4,2]Output: 3Note:  You must not modify the array ( assume the array is read only )  You must use only constant. O(1) extra space  Your runtime complexity should be less than O(n^2)  There is only one duplicate number in the array, but it could be repeated more than onceMy Answer  중간값(mid)를 이용해서 해결  nums에 있는 모든 요소의 범위는 1~n이다.  nums에 있는 요소들은 특정 값 x보다 같거나 작은것의 갯수는 중복 되는 것이 없을때 x가 나와야 한다.          [1,2,3,4], if x==2 일때 [1,2]=2, if x==3 일때 [1,2,3]        nums에 있는 요소들은 특정 값 x보다 같거나 작은것의 갯수는 중복 되는 것이 있을때 x보다 큰 값이 나와야 한다.          [1,2,2,3], if x==2 일때 [1,2,2]=3, if x==1 일때 [1]        위 조건대로라면, mid를 x라고 했을때 x보다 작거나 같은것의 갯수가 x보다 큰지 작은지에 따라 mid의 값을 변경해 주면 된다.class Solution {    public int findDuplicate(int[] nums) {        int l=0;        int r=nums.length-1;                while(l&lt;r){            int mid = (l+r)/2;            int count=0;                            for(int n : nums) {                if ( n &lt;= mid )                    count++;                     }                        if ( count &gt; mid ) {                r--;            } else {                l++;            }                    }                return l;            }}Fastest Answer  nums에 있는 모든 요소의 범위는 1~n이다.  slow, fast는 각각 늦은 index와 빠른 index를 의미 한다.  첫번째 do~while 문에서 slow는 순차 대로 접근 하고, fast는 slow 보다 2배 빠른 접근 한다. 그래서, slow와 fast를 동일한 빠르기로 접근할 수 있는 값을 찾는다. 예를 들어 다음과 같은 흐름이다.      Input: [1,3,4,2,2]  slow = 0, fast = 0  1:      slow = nums[0] = 1      fast = nums[nums[0]] = nums[1] = 3  2:      slow = nums[1] = 3      fast = nums[nums[3]] = nums[2] = 4  3:      slow = nums[3] = 2      fast = nums[nums[4]] = nums[2] = 4  4:      slow = nums[2] = 4      fast = nums[nums[4]] = nums[2] = 4  slow와 fast가 같아졌기 때문에 종료        두번째 while문에선 slow와 fast 둘다 동일한 순차 접근으로 동일한 값을 찾는다. 예를 들어 다음과 같은 흐름이다.      Input: [1,3,4,2,2]  위의 do~while을 통해 fast가 4로 결정났다.  slow = 0, fast = 4  1:      slow = nums[0] = 1      fast = nums[4] = 2  2:      slow = nums[1] = 3      fast = nums[2] = 4  3:      slow = nums[3] = 2      fast = nums[4] = 2  slow와 fast가 같아졌기 때문에 종료      class Solution {    public int findDuplicate(int[] nums) {        int slow=0;        int fast=0;                do {            slow = nums[slow];            fast = nums[nums[fast]];        } while(slow != fast);        slow = 0;                while(slow != fast ) {            slow = nums[slow];            fast = nums[fast];        }                return slow;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/find_duplicate_number.html"
      }        
      ,
    
      "leetcode-2020-02-03-fibonacci-number-html": {
        "title": "Fibonacci Number",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemThe Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1.Given N, calculate F(N).Example 1:Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.Example 2:Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.My Answer  중복 연산으로 인해서 N이 커질수록 연산시간이 오래 걸리기 때문에, 중간 결과값을 m_cache에서 기록 했다가 나중에 쓰자.class Solution {    HashMap&lt;Integer, Integer&gt; m_cache = new HashMap&lt;Integer, Integer&gt;();        public int fib(int N) {        if ( N == 0 )            return 0;                if ( N == 1)            return 1;                if ( m_cache.containsKey(N))            return m_cache.get(N);                int result = fib(N-1) + fib(N-2);        m_cache.put(N, result);        return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/fibonacci_number.html"
      }        
      ,
    
      "leetcode-2020-02-03-design-hashset-html": {
        "title": "Design HashSet",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemDesign a HashSet without using any built-in hash table libraries.To be specific, your design should include these functions:  add(value) : Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not.  remove(value) : Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.Example :MyHashSet hashSet = new MyHashSet();hashSet.add(1);         hashSet.add(2);         hashSet.contains(1);    // returns truehashSet.contains(3);    // returns false (not found)hashSet.add(2);          hashSet.contains(2);    // returns truehashSet.remove(2);          hashSet.contains(2);    // returns false (already removed)Note:  All values will be in the range of [0, 1000000]  The number of operations will be in the range of [1, 10000]  Please do not use the built-in HashSet libraryMy Answer  2차원 배열을 이용해서 값을 저장하자.  첫번째 index가 어떤 Bucket인지를 결정. value의 범위가 0~1000000이기 때문에, value / 1000를 첫번째 index를 구하는 함수로 사용 (getHash).  두번째 index가 Bucket에서 저장될 위치를 결정. value의 범위가 0~1000000이기 때문에, value % 1000를 두번째 index를 구하는 함수로 사용 ( getIndex).  add함수에서 파라미터로 넘어온 value에 맞춰서 getHash, getIndex를 구하고, 현재 2차원 배열의 길이가 Hash, Index 보다 작다면 사이즈를 키운다.class MyHashSet {    int[][] values;        public MyHashSet() {        values= new int[0][0];            }        public void add(int key) {        if ( contains(key))            return;                int hash = getHash(key);        if ( values.length &lt;= hash ) {            int[][] new_v = new int[hash + 1][];                        for(int i=0;i&lt;new_v.length;i++) {                if ( i &lt; values.length) {                    new_v[i] = new int[values[i].length];                    System.arraycopy(values[i], 0, new_v[i], 0, values[i].length);                    } else {                    new_v[i] = new int[0];                }                            }            values = new_v;        }                int index = getIndex(key);        int sub_count = values[hash].length;        if ( sub_count &lt;= index ) {            int[] new_sub = new int[index + 1];                for(int i=0;i&lt;new_sub.length;i++) {                int org_value = -1;                if ( i &lt; sub_count ) {                    org_value = values[hash][i];                }                                 new_sub[i] = org_value;            }            values[hash] = new_sub;        }                values[hash][index] = key;            }        public void remove(int key) {        if ( !contains(key)) return;                int hash = getHash(key);        int index = getIndex(key);                values[hash][index] = -1;    }        /** Returns true if this set contains the specified element */    public boolean contains(int key) {         int hash = getHash(key);                if ( values.length &lt;= hash ) return false;                int index = getIndex(key);        if ( values[hash].length &lt;= index ) return false;                if ( values[hash][index] != key ) return false;                return true;    }        int getHash(int key) {        return key / 1000;            }        int getIndex(int key) {        return key % 1000;    }}/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */",
        "url": "http://localhost:4000//leetcode/2020/02/03/design_hashset.html"
      }        
      ,
    
      "leetcode-2020-02-03-design-hashmap-html": {
        "title": "Design HashMap",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemDesign a HashMap without using any built-in hash table libraries.To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.  get(key) : Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.  remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.Example :MyHashMap hashMap = new MyHashMap();hashMap.put(1, 1);          hashMap.put(2, 2);         hashMap.get(1);            // returns 1hashMap.get(3);            // returns -1 (not found)hashMap.put(2, 1);          // update the existing valuehashMap.get(2);            // returns 1 hashMap.remove(2);          // remove the mapping for 2hashMap.get(2);            // returns -1 (not found) Note:  All keys and values will be in the range of [0, 1000000]  The number of operations will be in the range of [1, 10000]  Please do not use the built-in HashMap libraryMy Answer  2차원 배열을 이용해서 값을 저장하자.  첫번째 index가 어떤 Bucket인지를 결정. value의 범위가 0~1000000이기 때문에, value / 1000를 첫번째 index를 구하는 함수로 사용 (getHash).  두번째 index가 Bucket에서 저장될 위치를 결정. value의 범위가 0~1000000이기 때문에, value % 1000를 두번째 index를 구하는 함수로 사용 ( getIndex).  add함수에서 파라미터로 넘어온 value에 맞춰서 getHash, getIndex를 구하고, 현재 2차원 배열의 길이가 Hash, Index 보다 작다면 사이즈를 키운다.class MyHashMap {    int[][] values;    /** Initialize your data structure here. */    public MyHashMap() {        values=new int[0][0];    }        /** value will always be non-negative. */    public void put(int key, int value) {        if ( get(key) &gt;= 0 ) {            int hash = getHash(key);                int index = getIndex(key);            values[hash][index] = value;                        return;        }                    int hash = getHash(key);        if ( values.length &lt;= hash ) {            int[][] new_v = new int[hash + 1][];                        for(int i=0;i&lt;new_v.length;i++) {                if ( i &lt; values.length) {                    new_v[i] = new int[values[i].length];                    System.arraycopy(values[i], 0, new_v[i], 0, values[i].length);                    } else {                    new_v[i] = new int[0];                }                            }            values = new_v;        }                int index = getIndex(key);        int sub_count = values[hash].length;        if ( sub_count &lt;= index ) {            int[] new_sub = new int[index + 1];                for(int i=0;i&lt;new_sub.length;i++) {                int org_value = -1;                if ( i &lt; sub_count ) {                    org_value = values[hash][i];                }                                 new_sub[i] = org_value;            }            values[hash] = new_sub;        }                values[hash][index] = value;    }        /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    public int get(int key) {        int hash = getHash(key);                if ( values.length &lt;= hash ) return -1;                int index = getIndex(key);        if ( values[hash].length &lt;= index ) return -1;                return values[hash][index];    }        int getHash(int key) {        return key / 1000;            }        int getIndex(int key) {        return key % 1000;    }        /** Removes the mapping of the specified value key if this map contains a mapping for the key */    public void remove(int key) {        if ( get(key) &lt; 0 ) return;                int hash = getHash(key);        int index = getIndex(key);                values[hash][index] = -1;    }}/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */",
        "url": "http://localhost:4000//leetcode/2020/02/03/design_hashmap.html"
      }        
      ,
    
      "leetcode-2020-02-03-delete-node-in-bst-html": {
        "title": "Delete Node in a BST",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.Basically, the deletion can be divided into two stages:Search for a node to remove.If the node is found, delete the node.Example :Input: root = [5,3,6,2,4,null,7]key = 3    5   / \\  3   6 / \\   \\2   4   7Output: [5,4,6,2,null,null,7]    5   / \\  4   6 /     \\2       7Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.My Answer  key에 해당하는 target노드를 찾는다.  만약 target 노드의 자식이 없는 경우, target노드가 이전 노드의 왼쪽이면 prev.left를 오른쪽이면 prev.right를 null로 한다.  만약 target 노드의 자식이 하나만 있는 경우, target노드의 left가 있다면 prev.left = target.left, right가 있다면 prev.right = target.right  만약 target 노드의 자식이 둘 다 있는 경우, target노드의 자식 중 적절한 노드를 찾는다. target.right부터해서 left가 null이 아닐때 까지 찾는다.          BST에서 root를 대체 하기 가장 좋은 노드는 오른쪽의 가장 왼쪽 즉 오른쪽 노드들 중 가장 작은 것이다.              적절한 자식노드를 찾았다면, 해당 노드의 right가 null이 아니라면 이전 노드의 left에 할당하고, 그렇지 않다면 이전 노드의 left에 null을 할당한다.                  위 작업에 의해 적절한 자식노드가 없어져서 빈공간이 발생하는 것을 해결한다.                    target노드의 값을 찾은 적절한 자식노드의 값으로 변경해 준다.      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode deleteNode(TreeNode root, int key) {        TreeNode prev = null;        TreeNode curr = root;                boolean is_left = false;                while( curr != null ) {                        if ( curr.val == key ) {                if ( curr.left == null &amp;&amp; curr.right == null ) {        //자식이 아무것도 없는 경우                    if ( prev == null ) {                        root = null;                                            } else {                        if ( is_left ) prev.left = null;                        else prev.right = null;                    }                } else if ( curr.left != null &amp;&amp; curr.right != null ) { //자식이 둘다 있는 경우                    TreeNode properChild = searchChild(curr);                                        if( curr.right.val == properChild.val ) {                        curr.right = properChild.right;                    }                                        curr.val = properChild.val;                } else {    //자식이 둘중 하나만 있는 경우                    if ( prev == null ) {                        if ( curr.left != null ) {                            root = curr.left;                        } else {                            root = curr.right;                        }                                                } else {                        if ( is_left ) {                            prev.left = curr.left != null ? curr.left : curr.right;                                             } else {                            prev.right = curr.left != null ? curr.left : curr.right;                                             }                                            }                                    }                break;            } else {                is_left = curr.val &gt; key;                prev = curr;                curr = is_left ? curr.left : curr.right;                }        }                return root;            }        TreeNode searchChild(TreeNode root) {        TreeNode prev = root;        TreeNode curr = root.right;                while( curr.left != null ) {            prev = curr;            curr = curr.left;                        if ( curr.left == null ) {                if ( curr.right != null )                     prev.left = curr.right;                  else                     prev.left = null;            }         }                return curr;            }}Fastest Answer  재귀를 이용  순회 보다 훨씬 깔끔하다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode deleteNode(TreeNode root, int key) {        if (root == null) {            return root;        }        if (root.val == key) {            // only one children            if (root.left == null) {                return root.right;            } else if (root.right == null) {                return root.left;            }            // two children            TreeNode suc = inorderSuc(root.right);            root.val = suc.val;            root.right = deleteNode(root.right, root.val);        } else if (root.val &gt; key) {            root.left = deleteNode(root.left, key);        } else {            root.right = deleteNode(root.right, key);        }        return root;    }        public TreeNode inorderSuc(TreeNode root) {        while (root.left!= null) {            root = root.left;        }        return root;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/delete_node_in_bst.html"
      }        
      ,
    
      "leetcode-2020-02-03-convert-sorted-array-to-binary-search-tree-html": {
        "title": "Convert Sorted Array to Binary Search Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array where elements are sorted in ascending order, convert it to a height balanced BST.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Example:Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:      0     / \\   -3   9   /   / -10  5My Answer  재귀를 이용해서, 중간 index의 값을 해당 뎁스의 root로 사용하고, right, left를 추가한다.  기본적으로 이진탐색으로 mid, start, end index를 구한다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode sortedArrayToBST(int[] nums) {                TreeNode root = null;                root = AddNode(nums, 0, nums.length -1);                return root;                }        TreeNode AddNode(int[] nums, int start_idx, int end_idx ) {        if ( start_idx &gt; end_idx )  //start가 end 보다 커질경우는 더이상 찾을 값이 없다는 의미 이기 때문에 null로 처리            return null;                int mid = (start_idx + end_idx) / 2;    //중간 index를 찾고         TreeNode root = new TreeNode(nums[mid]);    //현재 뎁스의 root로 사용                if ( start_idx == end_idx ) //start와 end가 같다는건 mid를 제외한 다른 원소가 없다는 의미            return root;                root.right = AddNode(nums, mid +1, end_idx);    //mid +1 ~ end 까지를 이용해서 right를 채우고        root.left = AddNode(nums, start_idx, mid - 1);  //start ~ mid -1 까지를 이용해서 left를 채운다.                return root;            }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/convert_sorted_array_to_binary_search_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-convert-recursion-to-iteration-html": {
        "title": "Convert Recursion to Iteration",
        "tags": "LeetCode, Article",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "Definition재귀적으로 알고리즘을 구현하는것은 좋은 접근이나, 다음과 같은 이유에 의해서 재귀적으로 구현 못 하는경우가 발생한다.  Stackoverflow의 발생   재귀적인 알고리즘을 제대로 구현 하지 못했을때, Stackoverflow를 발생시킬 여지가 있다.  효율성재귀적인 함수 호출은 System Stack에 추가적인 메모리 할당이 요구 된다. 간혹 중복 계산의 문제가 발생할 수 있다. 예를 들어 Pascal’s Triangle  복잡성 재귀적인 알고리즘은 코드의 흐름을 이해하기 어렵게 만든다.Example2개의 Binary Tree가 있을때 같은지 다른지 확인 하는 코드를 재귀적으로, 반복적으로 구현하면 다음과 같이 할 수 있다.[Recursion]/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {  public boolean isSameTree(TreeNode p, TreeNode q) {    // p and q are both null    if (p == null &amp;&amp; q == null) return true;    // one of p and q is null    if (q == null || p == null) return false;    if (p.val != q.val) return false;    return isSameTree(p.right, q.right) &amp;&amp;            isSameTree(p.left, q.left);  }}[Iteration]class Solution {  public boolean check(TreeNode p, TreeNode q) {    // p and q are null    if (p == null &amp;&amp; q == null) return true;    // one of p and q is null    if (q == null || p == null) return false;    if (p.val != q.val) return false;    return true;  }  public boolean isSameTree(TreeNode p, TreeNode q) {    if (p == null &amp;&amp; q == null) return true;    if (!check(p, q)) return false;    // init deques    ArrayDeque&lt;TreeNode&gt; deqP = new ArrayDeque&lt;TreeNode&gt;();    ArrayDeque&lt;TreeNode&gt; deqQ = new ArrayDeque&lt;TreeNode&gt;();    deqP.addLast(p);    deqQ.addLast(q);    while (!deqP.isEmpty()) {      p = deqP.removeFirst();      q = deqQ.removeFirst();      if (!check(p, q)) return false;      if (p != null) {        // in Java nulls are not allowed in Deque        if (!check(p.left, q.left)) return false;        if (p.left != null) {          deqP.addLast(p.left);          deqQ.addLast(q.left);        }        if (!check(p.right, q.right)) return false;        if (p.right != null) {          deqP.addLast(p.right);          deqQ.addLast(q.right);        }      }    }    return true;  }}Conclusion재귀적인 알고리즘을 반복적인 알고리즘으로 변경할 땐 다음과 같은 흐름으로 하면 된다.  Stack이나 Queue같은 데이터 구조를 이용해서 재귀함수를 호출할 때 사용할 파라미터들을 추가해 주면된다.  미리 구성해 놓은 데이터 구조를 이용해서 반복 수행 하면 된다.",
        "url": "http://localhost:4000//leetcode/2020/02/03/convert_recursion_to_iteration.html"
      }        
      ,
    
      "leetcode-2020-02-03-contains-duplicate-iii-html": {
        "title": "Contains Duplicate III",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.Example 1:Input: nums = [1,2,3,1], k = 3, t = 0Output: trueExample 2:Input: nums = [1,0,1,1], k = 1, t = 2Output: trueExample 3:Input: nums = [1,5,9,1,5,9], k = 2, t = 3Output: falseNote:                My Answer  index i와 j의 차가 k보다 크지 않도록 유지 한다.  nums[i] 와 nums[j]의 차가 t보다 크지 않도록 유지 한다.  만약 위 조건을 만족하는 i가 있다면 true  i~j &lt;= k 범위에 있는 index l, r을 이용하자.  l과 r이 같지 않으면서, nums[r]-nums[l] &lt;= t를 만족한다면 true이다.  만약 r-l == k라면 l을 증가 시켜야 한다. 왜냐 하면, i~j &lt;= k 조건을 만족해야 하기 때문.  만약 r == nums.length -1라면 l을 증가 시켜야 한다. 왜냐 하면, nums[r]-nums[l] &lt;= t을 구하려면 r이 nums의 범위를 넘어 가선 안되기 때문이다.  l이 증가 될때, t가 0이 아니라면 r을 l+1로 변경해줘야 한다. 왜냐하면, 비교해야 하는 케이스를 건너띌수 있기 때문이다. 예를들어 다음과 같이 될 수 있다.      예를 들어  Input: nums = [1,8,9,5], k = 3, t = 0  2-1 &lt;= 3  nums[2]-nums[1] == 9-8 == 1 의 케이스가 있기 때문에 true이다. 하지만 r을 l+1로 해주는 코드가 없다면 다음과 같은 흐름이 된다.      1:      l=0,r=0  2:      l=0,r=1  3:      l=0,r=2  4:      l=0,r=3  5:      l=1,r=3  6:       l=2,r=3  2, 1을 비교 하는 케이스가 없어지기 때문에 false로 나온다.          class Solution {    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {        if ( k == 0 )            return false;                int l=0;        int r=0;                while( l &lt; nums.length -1 ) {            if ( r != l &amp;&amp; Math.abs((long)nums[r] - (long)nums[l]) &lt;= t )                return true;                        if ( r-l == k || r == nums.length - 1 ) {                l++;                                if(t!=0)                    r=l+1;                            } else {                r++;            }                    }                return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/contains_duplicate_iii.html"
      }        
      ,
    
      "leetcode-2020-02-03-contains-duplicate-ii-html": {
        "title": "Contains Duplicate II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.Example 1:Input: nums = [1,2,3,1], k = 3Output: trueExample 2:Input: nums = [1,0,1,1], k = 1Output: trueExample 3:Input: nums = [1,2,3,1,2,3], k = 2Output: falseMy Answer ( Use HashMap )  HashMap을 이용하자.  nums를 순회하면서, nums[i]를 HashMap의 키로, index를 값으로 할당하자.  만약 nums[i]가 Hashmap의 키로 존재하면서, 현재 index - 해당 값이 k보다 같거나 작으면 trueclass Solution {    public boolean containsNearbyDuplicate(int[] nums, int k) {        Map&lt;Integer, Integer&gt; hashmap = new HashMap&lt;&gt;();                for(int i=0;i&lt;nums.length;i++) {            if ( hashmap.containsKey(nums[i])) {                if ( i - hashmap.get(nums[i]) &lt;= k ) {                    return true;                                }             }                        hashmap.put(nums[i], i);            }                return false;    }}My Answer  index l,r을 이용해서, nums[l]과 nums[r]을 비교해서 알아내자.  만약 r-l이 k랑 같거나, r이 nums.length - 1과 같다면, l을 증가 시키자.  그렇지 않다면 r을 증가 시키자.  이런식으로 비교 하다가 nums[l]과 nums[r]이 같아지면 true이다.class Solution {    public boolean containsNearbyDuplicate(int[] nums, int k) {        if ( k == 0 ) return false;                 int l=0;        int r=0;                while( l &lt; nums.length -1 ) {                        if ( l != r &amp;&amp; nums[l] == nums[r] ) return true;                        if ( r-l == k || r == nums.length -1 ) {                l++;                            } else {                r++;            }                    }                return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/contains_duplicate_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-contains-duplicate-html": {
        "title": "Contains Duplicate",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array of integers, find if the array contains any duplicates.Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.Example 1:Input: [1,2,3,1]Output: trueExample 2:Input: [1,2,3,4]Output: trueExample 3:Input: [1,1,1,3,3,4,3,2,4,2]Output: trueMy Answer  nums에서 최소값과 최대값을 찾자. nums는 최소값과 최대값 사이에 있는 수로 이루어져 있기 때문에, 중복 여부를 체크할 boolean배열을 구성하는데, 최대값 - 최소값 +1 사이즈의 배열(table)을 만들자.  nums를 순회 하면서, 현재 숫자 (i)에서 최소값을 빼면 table의 index가 나오고, table[index]가 true면 중복된 수가 있다는 의미이다.class Solution {    public boolean containsDuplicate(int[] nums) {        int max = Integer.MIN_VALUE;        int min = Integer.MAX_VALUE;        for(int i : nums){            if(i &gt; max) max = i;            if(i &lt; min) min = i;        }        boolean[] table = new boolean[max - min + 1];        for(int i : nums){            if(table[i - min]) return true;            table[i - min] = true;        }        return false;    }}My Answer ( Use HashSet )class Solution {    public boolean containsDuplicate(int[] nums) {        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();                  for(int n : nums){            if ( hashSet.contains(n)) return true;                        hashSet.add(n);        }        return false;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/contains_duplicate.html"
      }        
      ,
    
      "leetcode-2020-02-03-container-with-most-water-html": {
        "title": "Container With Most Water",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note:  You may not slant the container and n is at least 2.  The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49My Answer  height 배열을 순회 하면서 각 영역 별 최대 값을 구하고, 비교한다.class Solution {    public int maxArea(int[] height) {        int max = 0;                for(int i=0;i &lt; height.length - 1;i++) {            int L = height[i];            for(int j = i + 1; j &lt; height.length; j++) {                int R = height[j];                int min = L &gt; R ? R : L;                                int n_total = (j - i) * min;                                if ( n_total &gt; max )                     max = n_total;            }        }                return max;               }}Fastest Answer  좌, 우 끝단 부터 시작 해서 최대 값을 구한다.  Explainclass Solution {    public int maxArea(int[] height) {        int left=0;        int right=height.length-1;        int most=0;        while (left &lt; right) {            int min = height[left] &lt; height[right] ? height[left] : height[right];             most = Math.max(most, min * (right - left));             if (height[left] &lt; height[right]) {                int oldLeft = height[left];                 while (height[left] &lt;= oldLeft &amp;&amp; left &lt; right) {                    left++;                }            }else{                int oldRight = height[right];                while (height[right] &lt;= oldRight &amp;&amp; left &lt; right) {                    right--;                }            }        }        return most;     }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/container_with_most_water.html"
      }        
      ,
    
      "leetcode-2020-02-03-construct-binarytree-from-preorder-n-inorder-traversal-html": {
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven preorder and inorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree.Example :Input: preorder = [3,9,20,15,7]inorder = [9,3,15,20,7]Output:     3   / \\  9  20    /  \\   15   7My Answer  재귀를 이용해서 해결  preorder 의 i_l의 위치에 있는 값이 Node의 값이다.  inorder에서 Node 값의 index 기준으로 왼쪽 값들이 left를 구성할 후보군, 오른쪽 값들이 right를 구성할 후보군이다.  만약 각 후보군이 하나라면, 해당 값으로 left or right의 값이다.  만약 left 후보군이 다수 라면, generateTree 함수를 재귀 호출 하면서 inorder 배열의 0~index 까지를 파라미터로 넘기고, i_l 에서 하나 더한 값을 파라미터로 넘긴다.  만약 right 후보군이 다수 라면, generateTree 함수를 재귀 호출 하면서 inorder 배열의 index+1~inorder갯수 까지를 파라미터로 넘기고, i_l 에서 index + 1을 더한값을 파라미터로 넘긴다.  위 예제는 다음과 같은 흐름으로 진행 된다.  ```swift          preorder = [3,9,20,15,7], inorder = [9,3,15,20,7], i_l = 0    preorder의 i_l에 해당하는 index의 값은 3이기 때문에 root의 값은 3  inorder에서 3의 인덱스는 1이므로, [9]가 left 후보군, [15,20,7]이 오른쪽 후보군  left 후보군의 갯수가 1개 이기 때문에 root.left는 9  right 후보군의 갯수가 1개 이상 이기 때문에 재귀 호출 하면서, i_l + 1 + 1인 2를 넘김      preorder = [3,9,20,15,7], inorder = [15,20,7], i_l = 2    preorder의 i_l에 해당하는 index의 값은 20이기 때문에 root의 값은 20  inorder에서 20의 인덱스는 1이므로, [15]가 left 후보군, [7]이 오른쪽 후보군  left 후보군의 갯수가 1개 이기 때문에 root.left는 15  right 후보군의 갯수가 1개 이기 때문에 root.right는 7  ```      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode buildTree(int[] preorder, int[] inorder) {        if ( preorder == null || preorder.length == 0 )            return null;                TreeNode root = generateTree(preorder, inorder, 0);                return root;    }        TreeNode generateTree(int[] preorder, int[] inorder, int i_l) {        TreeNode root = new TreeNode(preorder[i_l]);                int pivot = -1;     //inorder에서의 root의 값과 동일한 값의 index        for(int i=0;i&lt;inorder.length;i++) {            if ( inorder[i] == root.val) {                pivot = i;                break;            }                        }                if ( pivot == 1 ) {     //pivot 기준으로 왼쪽에 하나 밖에 없다면, 재귀 호출 필요 없음            root.left = new TreeNode(inorder[0]);        } else if ( pivot &gt;= 2 ) {     //pivot 기준으로 왼쪽에 두개 이상이라면, 재귀 호출            int[] left_array = Arrays.copyOfRange(inorder, 0, pivot);            root.left = generateTree(preorder, left_array, i_l+1);        }                if ( inorder.length - pivot == 2 ) {    //pivot 기준으로 오른쪽에 하나 밖에 없다면, 재귀 호출 필요 없음            root.right = new TreeNode(inorder[inorder.length - 1]);        } else if ( inorder.length - pivot &gt;= 3 ) { //pivot 기준으로 오른쪽에 두개 이상이라면, 재귀 호출            int[] right_array = Arrays.copyOfRange(inorder, pivot +1 , inorder.length);            // i_l에서 하나 다음 index에다가, 왼쪽 후보군의 갯수 (pivot)            root.right = generateTree(preorder, right_array, i_l+1 +  pivot);        }                return root;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/construct_binarytree_from_preorder_n_inorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-construct-binarytree-from-inorder-n-postorder-traversal-html": {
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven inorder and postorder traversal of a tree, construct the binary treeNote:You may assume that duplicates do not exist in the tree.Example :Input: inorder = [9,3,15,20,7]postorder = [9,15,7,20,3]Output:     3   / \\  9  20    /  \\   15   7My Answer  재귀를 이용해서 해결  postorder 의 i_r의 위치에 있는 값이 Node의 값이다.  inorder에서 Node 값의 index 기준으로 왼쪽 값들이 left를 구성할 후보군, 오른쪽 값들이 right를 구성할 후보군이다.  만약 각 후보군이 하나라면, 해당 값으로 left or right의 값이다.  만약 left 후보군이 다수 라면, generateTree 함수를 재귀 호출 하면서 inorder 배열의 0~index 까지를 파라미터로 넘기고, i_r 에서 오른쪽 후보군의 갯수 + 1만큼을 뺀 값을 파라미터로 넘긴다.  만약 right 후보군이 다수 라면, generateTree 함수를 재귀 호출 하면서 inorder 배열의 index+1~inorder갯수 까지를 파라미터로 넘기고, i_r 에서 하나 뺀 값을 파라미터로 넘긴다.  위 예제는 다음과 같은 흐름으로 진행 된다.  ```swift          inorder = [9,3,15,20,7], postorder = [9,15,7,20,3], i_r = 4    postorder의 i_r에 해당하는 index의 값은 3이기 때문에 root의 값은 3  inorder에서 3의 인덱스는 1이므로, [9]가 left 후보군, [15,20,7]이 오른쪽 후보군  left 후보군의 갯수가 1개 이기 때문에 root.left는 9  right 후보군의 갯수가 1개 이상 이기 때문에 재귀 호출 하면서, 마지막 인덱스 -1인 3을 넘김      inorder = [15,20,7], postorder = [9,15,7,20,3], i_r = 3    postorder의 i_r에 해당하는 index의 값은 20이기 때문에 root의 값은 20  inorder에서 20의 인덱스는 1이므로, [15]가 left 후보군, [7]이 오른쪽 후보군  left 후보군의 갯수가 1개 이기 때문에 root.left는 15  right 후보군의 갯수가 1개 이기 때문에 root.right는 7  ```      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode buildTree(int[] inorder, int[] postorder) {        if ( inorder == null || inorder.length == 0 )            return null;                     TreeNode root = generateTree(inorder, postorder, postorder.length - 1);                return root;    }        TreeNode generateTree(int[] inorder, int[] postorder, int i_r) {        TreeNode root = new TreeNode(postorder[i_r]);            int i = -1;     //inorder의 기준이 될 숫자의 index = pivot                for(int n=0;n &lt; inorder.length;n++) {            if ( inorder[n] == postorder[i_r]) {                i = n;                break;            }                        }                if ( i + 1 == inorder.length - 1 ) {    //pivot 기준으로 우측에 1개 밖에 없다면, 재귀 호출 필요 없이 바로 root.right            root.right = new TreeNode(inorder[inorder.length - 1]);        } else if ( i &gt;= 0 &amp;&amp; i + 2&lt; inorder.length ) {     //pivot 기준으로 우측에 2개 이상 있다면, 재귀 호출            int[] right_array = Arrays.copyOfRange(inorder, i+1, inorder.length);                root.right = generateTree(right_array, postorder, i_r - 1);        }                if ( i-1 == 0 ) {       //pivot 기준으로 좌측에 1개 밖에 없다면, 재귀 호출 필요 없이 바로 root.left            root.left = new TreeNode(inorder[0]);        } else if ( i -1 &gt; 0 ) {    //pivor 기준으로 좌측에 2개 이상 있다면, 재귀 호출            int[] left_array = Arrays.copyOfRange(inorder, 0, i);             //다음 i_r의 값은 현재 i_r에서 pivot 기준 오른쪽 요소들의 갯수 + 1을 뺀 값            root.left = generateTree(left_array, postorder, i_r -1 - (inorder.length - i -1));        }                 return root;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/construct_binarytree_from_inorder_n_postorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-combinations-html": {
        "title": "Combinations",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven two integers n and k, return all possible combinations of k numbers out of 1 … n.Example :Input: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]My Answer  재귀를 이용해서 해결  하나의 combination을 채우기 위한 추가 리스트 item을 만들고 여기에 순차대로 넣어 주자.  solver에서 start가 이번에 item에 넣을 숫자가 되고, 만약 item의 사이즈가 k와 동일할경우 결과 리스트 result에 현재 만들어진 item의 복사본을 만들어서 넣어 주자.  solver를 재귀 호출 한 이후 마지막 요소를 빼주면 다음 숫자를 넣을 수 있다.  만약 Example 처럼 n = 4, k = 2로 하고, for(int i = start ~ 구문의 내용을 다음과 같이 수정 하면      item.add(i);  System.out.format(\"add %d, %s\\n\", i, item);  solver(n,k,i+1, item, result);  item.remove(item.size() -1);  System.out.format(\"remove %s\\n\", item);        Console에 다음과 같이 출력된다.      add 1, [1]  add 2, [1, 2]  remove [1]  add 3, [1, 3]  remove [1]  add 4, [1, 4]  remove [1]  remove []  add 2, [2]  add 3, [2, 3]  remove [2]  add 4, [2, 4]  remove [2]  remove []  add 3, [3]  add 4, [3, 4]  remove [3]  remove []  add 4, [4]  remove []      class Solution {    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();                List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();        solver(n, k, 1, item, result);                    return result;    }        void solver(int n, int k, int start, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; result) {        if ( item.size() == k ) {            result.add(new ArrayList&lt;Integer&gt;(item));            return;        }                for(int i = start; i &lt;= n; i++) {            item.add(i);            solver(n,k,i+1, item, result);            item.remove(item.size() -1);        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/combinations.html"
      }        
      ,
    
      "leetcode-2020-02-03-climbing-stairs-html": {
        "title": "Climbing Stairs",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemYou are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Given n will be a positive integer.Example 1:Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsExample 2:Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 stepMy Answer  n이 1일때 결과는 1  n이 2일때 결과는 2  n이 3일때 결과는 3  n이 4일때 결과는 5  n이 4일때 결과는 8  위 처럼 결과가 나오기 때문에, Fibonacci number 처럼 처리 할 수 있다.class Solution {    HashMap&lt;Integer, Integer&gt; m_cache = new HashMap&lt;Integer, Integer&gt;();        public int climbStairs(int n) {        if ( n == 0 )                return 0;                if ( n == 1 )            return 1;                if ( n == 2 )            return 2;                if ( m_cache.containsKey(n))            return m_cache.get(n);                int result = climbStairs(n -1) + climbStairs(n - 2);        m_cache.put(n, result);                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/climbing_stairs.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-tree-preorder-traversal-html": {
        "title": "Binary Tree Preorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, return the preorder traversal of its nodes’ values.Example :Input: [1,null,2,3]   1    \\     2    /   3Output: [1,2,3]My Answer ( Recursive )  재귀로 해결  solver 함수에서 결과 리스트에 추가 하는 순서를 node -&gt; left -&gt; right 순으로 진행/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();                solver(result, root);                return result;    }        void solver(List&lt;Integer&gt; result, TreeNode root) {        if ( root == null )            return;                result.add(root.val);                if ( root.left != null ) {            solver(result, root.left);        }                if ( root.right != null ) {            solver(result, root.right);        }    }}My Answer ( Iteration )  반복문을 이용해서 해결  curr이 null이 될때 까지 반복 수행  일단 Stack에 curr을 넣자.  만약 curr의 left가 null인 경우엔 Stack에 있는것들 중에서 right가 null이 아닌것을 찾고 curr에 찾은것의 right를 넣으면 된다.  순서가 root -&gt; left -&gt; right 이기 때문에, left가 null이 라는것은 현재 노드에서 더이상 왼쪽으로 갈 것이 없다는 것이니 오른쪽이 있는 것을 찾아서 그 오른쪽을 다음 결과 리스트에 넣을 타겟 노드로 지정 하면 된다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();                Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();         TreeNode curr = root;                 while ( curr != null ) {                        result.add(curr.val);            s.push(curr);            curr = curr.left;                        if ( curr == null ) {                while( s.size() &gt; 0 ) {                    curr = s.pop().right;                    if ( curr != null )                        break;                }                }        }                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_tree_preorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-tree-postorder-traversal-html": {
        "title": "Binary Tree Postorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, return the postorder traversal of its nodes’ values.Example :Input: [1,null,2,3]   1    \\     2    /   3Output: [3,2,1]My Answer ( Recursive )  재귀로 해결  solver 함수에서 결과 리스트에 추가 하는 순서를 left -&gt; right -&gt; node 순으로 진행/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();                solver(result, root);                return result;    }        void solver(List&lt;Integer&gt; result, TreeNode root) {        if ( root == null )            return;                if ( root.left != null ) {            solver(result, root.left);        }                if ( root.right != null ) {            solver(result, root.right);        }                result.add(root.val);    }}My Answer ( Iteration )  반복문을 이용해서 해결  Stack에 순서대로 넣기만 하면 된다, 여기서 순서는 node -&gt; right -&gt; left  결과 리스트에 넣을땐 위 순서의 역순으로 집어 넣는다. 항상 첫번째 Index에 현재 노드의 값을 넣는다.  curr가 null이 라는것은 오른쪽은 다 했다는 의미니까 Stack에 있는것의 left를 curr에 할당해 주자./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        if (root == null) {            return result;        }        TreeNode curr = root;        while ( !stack.isEmpty() || curr != null) {            if (curr != null) {                stack.push(curr);                result.add(0, curr.val);                curr = curr.right;            } else {                TreeNode node = stack.pop();                curr = node.left;            }        }        return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_tree_postorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-tree-level-order-traversal-html": {
        "title": "Binary Tree Level Order Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).Example :Input: [3,9,20,null,null,15,7]    3   / \\  9  20    /  \\   15   7Output:[  [3],  [9,20],  [15,7]]My Answer ( Recursive )  재귀로 해결  solver 함수로 현재 Level과 Level별 값을 저장할 최종 리스트를 같이 넘겨서 Level 값을 기준으로 넣어야할 리스트를 찾아서 현재 Node의 값을 넣어 준다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();                solver(result, root, 0);                return result;    }        void solver(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode root, int level) {        if ( root == null )            return;                List&lt;Integer&gt; l_level = null;        if ( ans.size() &lt;= level ) {            l_level = new ArrayList&lt;Integer&gt;();            ans.add(l_level);        } else {            l_level = ans.get(level);        }                l_level.add(root.val);                if ( root.left != null ) {            solver(ans, root.left, level + 1);        }                if ( root.right != null ) {            solver(ans, root.right, level + 1);        }    }}My Answer ( Iteration_1 )  반복문을 이용해서 해결  다음 Level의 node들을 next_nodes에 저장하고, while문에서는 next_nodes를 순회 돌면서, node들의 값을 결과 리스트에 추가 한다.  node의 left와 right가 null이 아니라면 다음 순회를 위해서 next_nodes 리스트에 추가 하기 위해, temp_nodes 리스트에 추가 한다.  next_nodes 순회가 끝나면, next_nodes를 비우고 temp_nodes의 내용을 next_nodes에 채운 후, temp_nodes도 비운다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if ( root == null ) {            return result;        }                List&lt;TreeNode&gt; next_nodes = new ArrayList&lt;TreeNode&gt;();      //다음 Level의 Node들을 담고 있는 리스트        List&lt;TreeNode&gt; temp_nodes = new ArrayList&lt;TreeNode&gt;();      //result 리스트에 Node의 값을 넣은 이후 다음 Level의 Node들을 담을 임시 리스트        next_nodes.add(root);                while (next_nodes.size() &gt; 0 ) {        //next_nodes의 원소 갯수가 0개 라는것은 다음 Level에 해당하는 Node가 없다는 의미            List&lt;Integer&gt; sub_result = new ArrayList&lt;Integer&gt;();                        for(TreeNode node : next_nodes ) {                sub_result.add(node.val);                                if ( node.left != null )                    temp_nodes.add(node.left);                if ( node.right != null )                    temp_nodes.add(node.right);            }            next_nodes.clear();                        for(TreeNode node : temp_nodes ) {                next_nodes.add(node);            }            temp_nodes.clear();                        result.add(sub_result);        }                return result;    }}My Answer ( Iteration_2 )  반복문을 이용해서 해결  위의 My Answer ( Iteration_1 )는 2개의 List&lt;TreeNode&gt;를 사용했던것을 하나의 Queue&lt;TreeNode&gt;쓰는 방식으로 변경  while문 반복시 마다 현재 Queue에 있는 갯수 만큼 순회 하면서 결과 리스트에 넣고, 자식 노드를 넣어 준다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if ( root == null ) {            return result;        }                Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();                q.add(root);                while (q.size() &gt; 0 ) {                        List&lt;Integer&gt; sub_result = new ArrayList&lt;Integer&gt;();                        int n_size = q.size();            for( int n = 0; n &lt; n_size; n++ ) {                TreeNode node = q.poll();                sub_result.add(node.val);                                if ( node.left != null )                    q.add(node.left);                if ( node.right != null )                    q.add(node.right);            }                        result.add(sub_result);        }                return result;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_tree_level_order_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-tree-inorder-traversal-html": {
        "title": "Binary Tree Inorder Traversal",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, return the inorder traversal of its nodes’ values.Example :Input: [1,null,2,3]   1    \\     2    /   3Output: [1,3,2]My Answer ( Recursive )  재귀로 해결  solver 함수에서 결과 리스트에 추가 하는 순서를 left -&gt; node -&gt; right 순으로 진행/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();                solver(result, root);                return result;            }        void solver(List&lt;Integer&gt; ans, TreeNode node) {               if ( node == null )            return;                if ( node.left != null ) {            solver(ans, node.left);        }                ans.add(node.val);                if ( node.right != null ) {            solver(ans, node.right);        }    }}My Answer ( Iteration )  반복문을 이용해서 해결  left 노드를 우선으로 해서 Stack에 넣는다.  left 노드의 가장 마지막 leaf node 가 curr이 되는 순간 curr.left는 Null 이기때문에 while (curr !=  null) {  구문에서 빠져 나오게 되고, Stack의 최상단은 마지막 curr이 들어가 있다. 결과 리스트에 curr의 값을 넣고 curr.right를 넣는데, 이때 leaf node의 right는 Null 일것이기 때문에 while (curr !=  null) { 구문을 수행 하지 않고, curr = s.pop()이 수행되서 이전 left, leaf node의 parent node를 가리키게 된다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();                Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();         TreeNode curr = root;         while (curr != null || s.size() &gt; 0) {             while (curr !=  null) {     //Left 노드 우선으로 Stack에 넣는다, 만약 기존 curr이 right이면서 leafnode 라면 s의 상단에 추가 된다.                s.push(curr);                 curr = curr.left;             }               curr = s.pop();              result.add(curr.val);              curr = curr.right;         }                 return result;            }    }",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_tree_inorder_traversal.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-search-tree-iterator-html": {
        "title": "Binary Search Tree Iterator",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemImplement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Example 1:BSTIterator iterator = new BSTIterator(root);iterator.next();    // return 3iterator.next();    // return 7iterator.hasNext(); // return trueiterator.next();    // return 9iterator.hasNext(); // return trueiterator.next();    // return 15iterator.hasNext(); // return trueiterator.next();    // return 20iterator.hasNext(); // return falseNote:  next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.  You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.My Answer  작은 순서로 탐색하는것은 BST의 In-order탐색이다, Binary Tree Inorder Traversal  BSTIterator의 생성자에서, Queue(m_q)를 구성한다.  next()에선 m_q.poll() 하면된다.  hasNext()에선 m_q가 비어 있지만 않으면 true이다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class BSTIterator {    Queue&lt;Integer&gt; m_q;        public BSTIterator(TreeNode root) {        m_q = new LinkedList&lt;&gt;();        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        TreeNode curr = root;                while(curr != null || !s.isEmpty()) {            while(curr != null ) {                                s.push(curr);                curr = curr.left;            }                        curr = s.pop();            m_q.add(curr.val);                        curr = curr.right;        }                }        /** @return the next smallest number */    public int next() {        return m_q.poll();    }        /** @return whether we have a next smallest number */    public boolean hasNext() {        return !m_q.isEmpty();    }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */Fastest Answer  nxt가 다음 노드를 가리키는 객체이다.  next()에선 다음 노드의 값을 반환함과 동시에 nxt의 값을 다음 next()가 호출될때 사용할 값으로 할당한다.  right 값이 null 인것을 이용해서 다음 노드와의 연결을 만든다.  left가 null인 경우엔 next()의 타겟이 되는 노드는 nxt이고, 다음 노드는 nxt.right가 된다.  예를 들어 예제는 다음과 같은 흐름으로 진행된다.      Input : [7,3,15,null,null,9,20]  nxt = 7  next()      nxt = 3, 3's right is 7      res = 3, nxt = 7  next()      nxt = 7, 3's right is null      res = 7, nxt = 15  ...        3의 left, right 둘 다 처음엔 null이 였는데, next() 호출에서 right에 7을 할당해서 다음 호출시 사용한다./** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class BSTIterator {    TreeNode nxt;        public BSTIterator(TreeNode root) {        nxt = root;    }        /** @return the next smallest number */    public int next() {        TreeNode res = null;                while (nxt != null) {            if (nxt.left != null) {                TreeNode pre = nxt.left;                while (pre.right != null &amp;&amp; pre.right != nxt) {                    pre = pre.right;                }                                if (pre.right == null) {                    pre.right = nxt;                    nxt = nxt.left;                } else {                    pre.right = null;                    res = nxt;                    nxt = nxt.right;                    break;                }                            } else {                res = nxt;                nxt = nxt.right;                break;            }        }                return res.val;    }        /** @return whether we have a next smallest number */    public boolean hasNext() {        return nxt != null;    }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_search_tree_iterator.html"
      }        
      ,
    
      "leetcode-2020-02-03-binary-search-html": {
        "title": "Binary Search",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.Example 1:Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1Note :  You may assume that all elements in nums are unique.  n will be in the range [1,10000]  The value of each element in nums will be in the range [-9999,9999].My Answer  재귀를 이용해서 해결  l, r은 각각 nums에서 확인 해야할 시작 index와 마지막 index이다.  nums가 이미 정렬되어있기 때문에, l과 r의 중간값이 찾으려는 target인지 확인해서 중간값 과 같다면 해당 index를, target 보다 크다면 search를 재귀 호출 하면서 r에 pivot값을 넘기면 된다. target보다 작다면, l에 pivot+1을 넘기자.class Solution {    public int search(int[] nums, int target) {        return search(nums, target, 0, nums.length);            }        int search(int[] nums, int target, int l, int r) {                if ( l &gt;= r )            return -1;                int pivot = (l + r) / 2;        if ( nums[pivot] == target ) {            return pivot;        } else if ( nums[pivot] &gt; target ) {            return search(nums, target, l, pivot);        } else {            return search(nums, target, pivot + 1, r);        }    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/binary_search.html"
      }        
      ,
    
      "leetcode-2020-02-03-balanced-binary-tree-html": {
        "title": "Balanced Binary Tree",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.Example 1:Input: [3,9,20,null,null,15,7]    3   / \\  9  20    /  \\   15   7Output: trueExample 2:Input: [1,2,2,3,3,null,null,4,4]       1      / \\     2   2    / \\   3   3  / \\ 4   4Output: falseMy Answer  특정 TreeNode 기준으로 최대 깊이 값을 구하는 getMaxHeight 함수를 이용하자.  isBalanced에서 left, right 기준으로 최대 깊이를 구하고, 깊이의 차가 1보다 같거나 작으면 left, right에 대해서 계속 확인 하자. left나 right 둘 중에 하나라도 만족하지 않는다면 false  더 최적화할 여지가 있을것 같다.          getMaxHeight함수에 의해서 각 노드에 대해서 최대 높이 값을 구해놓은 상태 이기 때문에, isBalanced를 재귀 호출 할 때 다른식으로 할 수 있지 않을까?      /** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public boolean isBalanced(TreeNode root) {        if ( root == null )            return true;        int height_l = getMaxHeight(root.left, 0);        int height_r = getMaxHeight(root.right, 0);                if ( Math.abs(height_r - height_l) &lt;= 1 ) { //현재 노드 기준으로는 만족 했다. left, right 노드에 대해서 확인 하자.            return isBalanced(root.left) &amp;&amp; isBalanced(root.right);            } else {            return false;        }    }        int getMaxHeight(TreeNode root, int height) {        if ( root == null )            return height;                height++;                    if ( root.left == null &amp;&amp; root.right == null )            return height;                int height_l = getMaxHeight(root.left, height);        int height_r = getMaxHeight(root.right, height);                return Math.max(height_l, height_r);    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/balanced_binary_tree.html"
      }        
      ,
    
      "leetcode-2020-02-03-add-two-numbers-html": {
        "title": "Add Two Numbers",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example :Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.My Answer  l1와 l2의 끝 Node까지 순회하자.  순회하면서, l1, l2의 val의 합을 구하자.  만약 합이 10 이상이면 다음 Node의 합을 구할때 1을 추가로 더해줘야 하기 때문에, int 변수에 저장하자.  만약 l1, l2의 끝 까지 순회 했는데 마지막 연산으로 인해 10이상이 됬을수도 있으니, 확인해서 마지막에 Node(1)을 추가해 주자./** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode res = new ListNode(0);                ListNode cur = res;                int n_ex = 0;        while(l1 != null || l2 != null ) {            int n_1 = 0;            int n_2 = 0;                        if ( l1 != null ) {                n_1 = l1.val;                l1 = l1.next;            }                        if ( l2 != null ) {                n_2 = l2.val;                l2 = l2.next;            }                        int sum = n_1 + n_2 + n_ex;            if ( sum &gt;= 10 ) {                n_ex = 1;                sum %= 10;            } else {                n_ex = 0;            }                        cur.next = new ListNode(sum);            cur = cur.next;        }                if ( n_ex &gt; 0 ) {            cur.next = new ListNode(1);        }                    return res.next;            }            }Fastest Answer  l1, l2의 합 연산 과 올림에 의한것도 while에서 한큐에 진행  필요 없는 int 변수를 덜 만들었다.class Solution {public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    int carry = 0;    ListNode p, dummy = new ListNode(0);    p = dummy;    while (l1 != null || l2 != null || carry != 0) {        if (l1 != null) {            carry += l1.val;            l1 = l1.next;        }        if (l2 != null) {            carry += l2.val;            l2 = l2.next;        }        p.next = new ListNode(carry%10);        carry /= 10;        p = p.next;    }    return dummy.next;}}",
        "url": "http://localhost:4000//leetcode/2020/02/03/add_two_numbers.html"
      }        
      ,
    
      "leetcode-2020-02-03-add-search-word-html": {
        "title": "Add and Search Word - Data structure design",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemDesign a data structure that supports the following two operations:void addWord(word)boolean search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.Example :addWord(\"bad\")addWord(\"dad\")addWord(\"mad\")search(\"pad\") -&gt; falsesearch(\"bad\") -&gt; truesearch(\".ad\") -&gt; truesearch(\"b..\") -&gt; trueNote :  You may assume that all words are consist of lowercase letters a-zMy Answer  search 에선 재귀 함수를 이용하자.  만약 word의 문자가 .이라면, 현재 Trie의 자식들을 순회하자. 하나라도 true라면 정답class Trie {    public boolean isWord;    public Trie[] children;        public Trie() {        children = new Trie[26];    }}class WordDictionary {    Trie root;    /** Initialize your data structure here. */    public WordDictionary() {        root = new Trie();    }        /** Adds a word into the data structure. */    public void addWord(String word) {        Trie cur = root;        char[] array = word.toCharArray();        for(char c : array ) {            if ( cur.children[c-'a'] == null ) {                cur.children[c-'a'] = new Trie();                            }                        cur = cur.children[c-'a'];           }                cur.isWord = true;    }        /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */    public boolean search(String word) {        return search(root, word.toCharArray(), 0);            }        boolean search(Trie trie, char[] array, int idx) {         if ( trie == null ) return false;        if ( idx == array.length ) return trie.isWord;                    char c = array[idx];                if ( c == '.') {        //모든 자식들 중에 만족하는것이 있는지 확인해야 한다.            for(Trie t : trie.children ) {                if ( search(t, array, idx+1) )  //만족 하는게 있다면 더 이상 확인할 필요 없다.                    return true;                                        }                        return false;       //아무것도 만족 하지 않는 다면 false        }         return search(trie.children[c-'a'], array, idx + 1);            }}/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */",
        "url": "http://localhost:4000//leetcode/2020/02/03/add_search_word.html"
      }        
      ,
    
      "leetcode-2020-02-03-4sum-ii-html": {
        "title": "4Sum II",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.Example :Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0My Answer  위 문제는 다음과 같은 수식으로 생각 할 수 있다. A+B+C+D=A+B-(A+B)=0  즉, C+D == -(A+B) 를 만족하는 케이스를 찾아야 한다.  A,B 배열의 조합을 통해 나올 수 있는 A+B를 HashMap의 키로하고, 발생 횟수를 값으로 하자.  C,D 배열의 조합을 통해 나올 수 있는 -(C+D)를 HashMap의 키로 사용되는것을 찾고 결과에 더해 주자.class Solution {        public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {        int count = 0;        Map&lt;Integer, Integer&gt; hashmap = new HashMap&lt;&gt;();                for( int a : A ) {            for( int b : B ) {                hashmap.put(a+b, hashmap.getOrDefault(a+b, 0) + 1);            }        }                for( int c : C ) {            for( int d : D ) {                count += hashmap.getOrDefault(-c-d, 0);            }        }                return count;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/4sum_ii.html"
      }        
      ,
    
      "leetcode-2020-02-03-3sum-html": {
        "title": "3Sum",
        "tags": "LeetCode, Java",
        "date": "February 3, 2020",
        "author": "",
        "category": "",
        "content": "ProblemGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:  The solution set must not contain duplicate triplets.Example 1:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[  [-1, 0, 1],  [-1, -1, 2]]My Answer  정렬  nums를 순회돌면서 각 index를 기준으로 이진탐색을 수행  만약 이전에 했던 기준값이라면 continue  Explainclass Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        Arrays.sort(nums);                List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();                for(int i = 0;i &lt; nums.length - 2;i++) {        //한번에 3개를 가지고 체크하기 때문에 끝에서 3번째 까지만 돌면 된다.            int base = nums[i];                        if ( i &gt; 0 &amp;&amp; nums[i-1] == base )   //이전의 기준값과 같은 값이면 할 필요 없다                continue;                        int left = i + 1;            int right = nums.length - 1;                        while( left &lt; right ) {                           int sum = base + nums[left] + nums[right];                                if ( sum == 0 ) {                    res.add(Arrays.asList(base, nums[left], nums[right]));                                        int orgLeft = nums[left];                    int orgRight = nums[right];                                        while( left &lt; nums.length &amp;&amp; orgLeft == nums[left] ) {  //그 다음 값을 찾았는데, 이전에 사용했던 값과 동일할 수 있다 다를때까지 Index 증가 시키자                        left++;                    }                                                  while( right &gt;= 0 &amp;&amp; orgRight == nums[right] ) {   //그 다음 값을 찾았는데, 이전에 사용했던 값과 동일할 수 있다 다를때까지 Index 감소 시키자                        right--;                    }                } else if ( sum &gt; 0 ){                      right--;                } else {                    left++;                }            }        }                return res;    }}",
        "url": "http://localhost:4000//leetcode/2020/02/03/3sum.html"
      }        
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    



  </body>
</html>
